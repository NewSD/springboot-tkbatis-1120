#!/usr/bin/env python
# coding: utf-8

# module pyparsing.py
#
# Copyright (c) 2003-2013  Paul T. McGuire
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

__doc__ = \
"""
pyparsing module - Classes and methods to define and execute parsing grammars

The pyparsing module is an alternative approach to creating and executing simple grammars,
vs. the traditional lex/yacc approach, or the use of regular expressions.  With pyparsing, you
don't need to learn a new syntax for defining grammars or matching expressions - the parsing module
provides a library of classes that you use to construct the grammar directly in Python.

Here is a program to parse "Hello, World!" (or any greeting of the form C{"<salutation>, <addressee>!"})::

    from pyparsing import Word, alphas

    # define grammar of a greeting
    greet = Word( alphas ) + "," + Word( alphas ) + "!"

    hello = "Hello, World!"
    print (hello, "->", greet.parseString( hello ))

The program outputs the following::

    Hello, World! -> ['Hello', ',', 'World', '!']

The Python representation of the grammar is quite readable, owing to the self-explanatory
class names, and the use of '+', '|' and '^' operators.

The parsed results returned from C{parseString()} can be accessed as a nested list, a dictionary, or an
object with named attributes.

The pyparsing module handles some of the problems that are typically vexing when writing text parsers:
 - extra or missing whitespace (the above program will also handle "Hello,World!", "Hello  ,  World  !", etc.)
 - quoted strings
 - embedded comments
"""

__version__ = "2.0.3"
__versionTime__ = "16 Aug 2014 00:12"
__author__ = "Paul McGuire <ptmcg@users.sourceforge.net>"

import string
from weakref import ref as wkref
import copy
import sys
import warnings
import re
import sre_constants
import collections
import pprint
#~ sys.stderr.write( "testing pyparsing module, version %s, %s\n" % (__version__,__versionTime__ ) )

__all__ = [
'And', 'CaselessKeyword', 'CaselessLiteral', 'CharsNotIn', 'Combine', 'Dict', 'Each', 'Empty',
'FollowedBy', 'Forward', 'GoToColumn', 'Group', 'Keyword', 'LineEnd', 'LineStart', 'Literal',
'MatchFirst', 'NoMatch', 'NotAny', 'OneOrMore', 'OnlyOnce', 'Optional', 'Or',
'ParseBaseException', 'ParseElementEnhance', 'ParseException', 'ParseExpression', 'ParseFatalException',
'ParseResults', 'ParseSyntaxException', 'ParserElement', 'QuotedString', 'RecursiveGrammarException',
'Regex', 'SkipTo', 'StringEnd', 'StringStart', 'Suppress', 'Token', 'TokenConverter', 'Upcase',
'White', 'Word', 'WordEnd', 'WordStart', 'ZeroOrMore',
'alphanums', 'alphas', 'alphas8bit', 'anyCloseTag', 'anyOpenTag', 'cStyleComment', 'col',
'commaSeparatedList', 'commonHTMLEntity', 'countedArray', 'cppStyleComment', 'dblQuotedString',
'dblSlashComment', 'delimitedList', 'dictOf', 'downcaseTokens', 'empty', 'hexnums',
'htmlComment', 'javaStyleComment', 'keepOriginalText', 'line', 'lineEnd', 'lineStart', 'lineno',
'makeHTMLTags', 'makeXMLTags', 'matchOnlyAtCol', 'matchPreviousExpr', 'matchPreviousLiteral',
'nestedExpr', 'nullDebugAction', 'nums', 'oneOf', 'opAssoc', 'operatorPrecedence', 'printables',
'punc8bit', 'pythonStyleComment', 'quotedString', 'removeQuotes', 'replaceHTMLEntity',
'replaceWith', 'restOfLine', 'sglQuotedString', 'srange', 'stringEnd',
'stringStart', 'traceParseAction', 'unicodeString', 'upcaseTokens', 'withAttribute',
'indentedBlock', 'originalTextFor', 'ungroup', 'infixNotation','locatedExpr',
]

PY_3 = sys.version.startswith('3')
if PY_3:
    _MAX_INT = sys.maxsize
    basestring = str
    unichr = chr
    _ustr = str

    # build list of single arg builtins, that can be used as parse actions
    singleArgBuiltins = [sum, len, sorted, reversed, list, tuple, set, any, all, min, max]

else:
    _MAX_INT = sys.maxint
    range = xrange

    def _ustr(obj):
        """Drop-in replacement for str(obj) that tries to be Unicode friendly. It first tries
           str(obj). If that fails with a UnicodeEncodeError, then it tries unicode(obj). It
           then < returns the unicode object | encodes it with the default encoding | ... >.
        """
        if isinstance(obj,unicode):
            return obj

        try:
            # If this works, then _ustr(obj) has the same behaviour as str(obj), so
            # it won't break any existing code.
            return str(obj)

        except UnicodeEncodeError:
            # The Python docs (http://docs.python.org/ref/customization.html#l2h-182)
            # state that "The return value must be a string object". However, does a
            # unicode object (being a subclass of basestring) count as a "string
            # object"?
            # If so, then return a unicode object:
            return unicode(obj)
            # Else encode it... but how? There are many choices... :)
            # Replace unprintables with escape codes?
            #return unicode(obj).encode(sys.getdefaultencoding(), 'backslashreplace_errors')
            # Replace unprintables with question marks?
            #return unicode(obj).encode(sys.getdefaultencoding(), 'replace')
            # ...

    # build list of single arg builtins, tolerant of Python version, that can be used as parse actions
    singleArgBuiltins = []
    import __builtin__
    for fname in "sum len sorted reversed list tuple set any all min max".split():
        try:
            singleArgBuiltins.append(getattr(__builtin__,fname))
        except AttributeError:
            continue

_generatorType = type((y for y in range(1)))

def _xml_escape(data):
    """Escape &, <, >, ", ', etc. in a string of data."""

    # ampersand must be replaced first
    from_symbols = '&><"\''
    to_symbols = ('&'+s+';' for s in "amp gt lt quot apos".split())
    for from_,to_ in zip(from_symbols, to_symbols):
        data = data.replace(from_, to_)
    return data

class _Constants(object):
    pass

alphas = string.ascii_lowercase + string.ascii_uppercase
nums       = "0123456789"
hexnums    = nums + "ABCDEFabcdef"
alphanums  = alphas + nums
_bslash    = chr(92)
printables = "".join(c for c in string.printable if c not in string.whitespace)

class ParseBaseException(Exception):
    """base exception class for all parsing runtime exceptions"""
    # Performance tuning: we construct a *lot* of these, so keep this
    # constructor as small and fast as possible
    def __init__( self, pstr, loc=0, msg=None, elem=None ):
        self.loc = loc
        if msg is None:
            self.msg = pstr
            self.pstr = ""
        else:
            self.msg = msg
            self.pstr = pstr
        self.parserElement = elem

    def __getattr__( self, aname ):
        """supported attributes by name are:
            - lineno - returns the line number of the exception text
            - col - returns the column number of the exception text
            - line - returns the line containing the exception text
        """
        if( aname == "lineno" ):
            return lineno( self.loc, self.pstr )
        elif( aname in ("col", "column") ):
            return col( self.loc, self.pstr )
        elif( aname == "line" ):
            return line( self.loc, self.pstr )
        else:
            raise AttributeError(aname)

    def __str__( self ):
        return "%s (at char %d), (line:%d, col:%d)" % \
                ( self.msg, self.loc, self.lineno, self.column )
    def __repr__( self ):
        return _ustr(self)
    def markInputline( self, markerString = ">!<" ):
        """Extracts the exception line from the input string, and marks
           the location of the exception with a special symbol.
        """
        line_str = self.line
        line_column = self.column - 1
        if markerString:
            line_str = "".join((line_str[:line_column],
                                markerString, line_str[line_column:]))
        return line_str.strip()
    def __dir__(self):
        return "loc msg pstr parserElement lineno col line " \
               "markInputline __str__ __repr__".split()

class ParseException(ParseBaseException):
    """exception thrown when parse expressions don't match class;
       supported attributes by name are:
        - lineno - returns the line number of the exception text
        - col - returns the column number of the exception text
        - line - returns the line containing the exception text
    """
    pass

class ParseFatalException(ParseBaseException):
    """user-throwable exception thrown when inconsistent parse content
       is found; stops all parsing immediately"""
    pass

class ParseSyntaxException(ParseFatalException):
    """just like C{L{ParseFatalException}}, but thrown internally when an
       C{L{ErrorStop<And._ErrorStop>}} ('-' operator) indicates that parsing is to stop immediately because
       an unbacktrackable syntax error has been found"""
    def __init__(self, pe):
        super(ParseSyntaxException, self).__init__(
                                    pe.pstr, pe.loc, pe.msg, pe.parserElement)

#~ class ReparseException(ParseBaseException):
    #~ """Experimental class - parse actions can raise this exception to cause
       #~ pyparsing to reparse the input string:
        #~ - with a modified input string, and/or
        #~ - with a modified start location
       #~ Set the values of the ReparseException in the constructor, and raise the
       #~ exception in a parse action to cause pyparsing to use the new string/location.
       #~ Setting the values as None causes no change to be made.
       #~ """
    #~ def __init_( self, newstring, restartLoc ):
        #~ self.newParseText = newstring
        #~ self.reparseLoc = restartLoc

class RecursiveGrammarException(Exception):
    """exception thrown by C{validate()} if the grammar could be improperly recursive"""
    def __init__( self, parseElementList ):
        self.parseElementTrace = parseElementList

    def __str__( self ):
        return "RecursiveGrammarException: %s" % self.parseElementTrace

class _ParseResultsWithOffset(object):
    def __init__(self,p1,p2):
        self.tup = (p1,p2)
    def __getitem__(self,i):
        return self.tup[i]
    def __repr__(self):
        return repr(self.tup)
    def setOffset(self,i):
        self.tup = (self.tup[0],i)

class ParseResults(object):
    """Structured parse results, to provide multiple means of access to the parsed data:
       - as a list (C{len(results)})
       - by list index (C{results[0], results[1]}, etc.)
       - by attribute (C{results.<resultsName>})
       """
    def __new__(cls, toklist, name=None, asList=True, modal=True ):
        if isinstance(toklist, cls):
            return toklist
        retobj = object.__new__(cls)
        retobj.__doinit = True
        return retobj

    # Performance tuning: we construct a *lot* of these, so keep this
    # constructor as small and fast as possible
    def __init__( self, toklist, name=None, asList=True, modal=True, isinstance=isinstance ):
        if self.__doinit:
            self.__doinit = False
            self.__name = None
            self.__parent = None
            self.__accumNames = {}
            if isinstance(toklist, list):
                self.__toklist = toklist[:]
            elif isinstance(toklist, _generatorType):
                self.__toklist = list(toklist)
            else:
                self.__toklist = [toklist]
            self.__tokdict = dict()

        if name is not None and name:
            if not modal:
                self.__accumNames[name] = 0
            if isinstance(name,int):
                name = _ustr(name) # will always return a str, but use _ustr for consistency
            self.__name = name
            if not (isinstance(toklist, (type(None), basestring, list)) and toklist in (None,'',[])):
                if isinstance(toklist,basestring):
                    toklist = [ toklist ]
                if asList:
                    if isinstance(toklist,ParseResults):
                        self[name] = _ParseResultsWithOffset(toklist.copy(),0)
                    else:
                        self[name] = _ParseResultsWithOffset(ParseResults(toklist[0]),0)
                    self[name].__name = name
                else:
                    try:
                        self[name] = toklist[0]
                    except (KeyError,TypeError,IndexError):
                        self[name] = toklist

    def __getitem__( self, i ):
        if isinstance( i, (int,slice) ):
            return self.__toklist[i]
        else:
            if i not in self.__accumNames:
                return self.__tokdict[i][-1][0]
            else:
                return ParseResults([ v[0] for v in self.__tokdict[i] ])

    def __setitem__( self, k, v, isinstance=isinstance ):
        if isinstance(v,_ParseResultsWithOffset):
            self.__tokdict[k] = self.__tokdict.get(k,list()) + [v]
            sub = v[0]
        elif isinstance(k,int):
            self.__toklist[k] = v
            sub = v
        else:
            self.__tokdict[k] = self.__tokdict.get(k,list()) + [_ParseResultsWithOffset(v,0)]
            sub = v
        if isinstance(sub,ParseResults):
            sub.__parent = wkref(self)

    def __delitem__( self, i ):
        if isinstance(i,(int,slice)):
            mylen = len( self.__toklist )
            del self.__toklist[i]

            # convert int to slice
            if isinstance(i, int):
                if i < 0:
                    i += mylen
                i = slice(i, i+1)
            # get removed indices
            removed = list(range(*i.indices(mylen)))
            removed.reverse()
            # fixup indices in token dictionary
            for name in self.__tokdict:
                occurrences = self.__tokdict[name]
                for j in removed:
                    for k, (value, position) in enumerate(occurrences):
                        occurrences[k] = _ParseResultsWithOffset(value, position - (position > j))
        else:
            del self.__tokdict[i]

    def __contains__( self, k ):
        return k in self.__tokdict

    def __len__( self ): return len( self.__toklist )
    def __bool__(self): return len( self.__toklist ) > 0
    __nonzero__ = __bool__
    def __iter__( self ): return iter( self.__toklist )
    def __reversed__( self ): return iter( self.__toklist[::-1] )
    def iterkeys( self ):
        """Returns all named result keys."""
        if hasattr(self.__tokdict, "iterkeys"):
            return self.__tokdict.iterkeys()
        else:
            return iter(self.__tokdict)

    def itervalues( self ):
        """Returns all named result values."""
        return (self[k] for k in self.iterkeys())

    def iteritems( self ):
        return ((k, self[k]) for k in self.iterkeys())

    if PY_3:
        keys = iterkeys
        values = itervalues
        items = iteritems
    else:
        def keys( self ):
            """Returns all named result keys."""
            return list(self.iterkeys())

        def values( self ):
            """Returns all named result values."""
            return list(self.itervalues())

        def items( self ):
            """Returns all named result keys and values as a list of tuples."""
            return list(self.iteritems())

    def haskeys( self ):
        """Since keys() returns an iterator, this method is helpful in bypassing
           code that looks for the existence of any defined results names."""
        return bool(self.__tokdict)

    def pop( self, *args, **kwargs):
        """Removes and returns item at specified index (default=last).
           Supports both list and dict semantics for pop(). If passed no
           argument or an integer argument, it will use list semantics
           and pop tokens from the list of parsed tokens. If passed a
           non-integer argument (most likely a string), it will use dict
           semantics and pop the corresponding value from any defined
           results names. A second default return value argument is
           supported, just as in dict.pop()."""
        if not args:
            args = [-1]
        for k,v in kwargs.items():
            if k == 'default':
                args = (args[0], v)
            else:
                raise TypeError("pop() got an unexpected keyword argument '%s'" % k)
        if (isinstance(args[0], int) or
                        len(args) == 1 or
                        args[0] in self):
            index = args[0]
            ret = self[index]
            del self[index]
            return ret
        else:
            defaultvalue = args[1]
            return defaultvalue

    def get(self, key, defaultValue=None):
        """Returns named result matching the given key, or if there is no
           such name, then returns the given C{defaultValue} or C{None} if no
           C{defaultValue} is specified."""
        if key in self:
            return self[key]
        else:
            return defaultValue

    def insert( self, index, insStr ):
        """Inserts new element at location index in the list of parsed tokens."""
        self.__toklist.insert(index, insStr)
        # fixup indices in token dictionary
        for name in self.__tokdict:
            occurrences = self.__tokdict[name]
            for k, (value, position) in enumerate(occurrences):
                occurrences[k] = _ParseResultsWithOffset(value, position + (position > index))

    def append( self, item ):
        """Add single element to end of ParseResults list of elements."""
        self.__toklist.append(item)

    def extend( self, itemseq ):
        """Add sequence of elements to end of ParseResults list of elements."""
        if isinstance(itemseq, ParseResults):
            self += itemseq
        else:
            self.__toklist.extend(itemseq)

    def clear( self ):
        """Clear all elements and results names."""
        del self.__toklist[:]
        self.__tokdict.clear()

    def __getattr__( self, name ):
        try:
            return self[name]
        except KeyError:
            return ""

        if name in self.__tokdict:
            if name not in self.__accumNames:
                return self.__tokdict[name][-1][0]
            else:
                return ParseResults([ v[0] for v in self.__tokdict[name] ])
        else:
            return ""

    def __add__( self, other ):
        ret = self.copy()
        ret += other
        return ret

    def __iadd__( self, other ):
        if other.__tokdict:
            offset = len(self.__toklist)
            addoffset = ( lambda a: (a<0 and offset) or (a+offset) )
            otheritems = other.__tokdict.items()
            otherdictitems = [(k, _ParseResultsWithOffset(v[0],addoffset(v[1])) )
                                for (k,vlist) in otheritems for v in vlist]
            for k,v in otherdictitems:
                self[k] = v
                if isinstance(v[0],ParseResults):
                    v[0].__parent = wkref(self)

        self.__toklist += other.__toklist
        self.__accumNames.update( other.__accumNames )
        return self

    def __radd__(self, other):
        if isinstance(other,int) and other == 0:
            return self.copy()

    def __repr__( self ):
        return "(%s, %s)" % ( repr( self.__toklist ), repr( self.__tokdict ) )

    def __str__( self ):
        out = []
        for i in self.__toklist:
            if isinstance(i, ParseResults):
                out.append(_ustr(i))
            else:
                out.append(repr(i))
        return '[' + ', '.join(out) + ']'

    def _asStringList( self, sep='' ):
        out = []
        for item in self.__toklist:
            if out and sep:
                out.append(sep)
            if isinstance( item, ParseResults ):
                out += item._asStringList()
            else:
                out.append( _ustr(item) )
        return out

    def asList( self ):
        """Returns the parse results as a nested list of matching tokens, all converted to strings."""
        out = []
        for res in self.__toklist:
            if isinstance(res,ParseResults):
                out.append( res.asList() )
            else:
                out.append( res )
        return out

    def asDict( self ):
        """Returns the named parse results as dictionary."""
        if PY_3:
            return dict( self.items() )
        else:
            return dict( self.iteritems() )

    def copy( self ):
        """Returns a new copy of a C{ParseResults} object."""
        ret = ParseResults( self.__toklist )
        ret.__tokdict = self.__tokdict.copy()
        ret.__parent = self.__parent
        ret.__accumNames.update( self.__accumNames )
        ret.__name = self.__name
        return ret

    def asXML( self, doctag=None, namedItemsOnly=False, indent="", formatted=True ):
        """Returns the parse results as XML. Tags are created for tokens and lists that have defined results names."""
        nl = "\n"
        out = []
        namedItems = dict((v[1],k) for (k,vlist) in self.__tokdict.items()
                                                            for v in vlist)
        nextLevelIndent = indent + "  "

        # collapse out indents if formatting is not desired
        if not formatted:
            indent = ""
            nextLevelIndent = ""
            nl = ""

        selfTag = None
        if doctag is not None:
            selfTag = doctag
        else:
            if self.__name:
                selfTag = self.__name

        if not selfTag:
            if namedItemsOnly:
                return ""
            else:
                selfTag = "ITEM"

        out += [ nl, indent, "<", selfTag, ">" ]

        worklist = self.__toklist
        for i,res in enumerate(worklist):
            if isinstance(res,ParseResults):
                if i in namedItems:
                    out += [ res.asXML(namedItems[i],
                                        namedItemsOnly and doctag is None,
                                        nextLevelIndent,
                                        formatted)]
                else:
                    out += [ res.asXML(None,
                                        namedItemsOnly and doctag is None,
                                        nextLevelIndent,
                                        formatted)]
            else:
                # individual token, see if there is a name for it
                resTag = None
                if i in namedItems:
                    resTag = namedItems[i]
                if not resTag:
                    if namedItemsOnly:
                        continue
                    else:
                        resTag = "ITEM"
                xmlBodyText = _xml_escape(_ustr(res))
                out += [ nl, nextLevelIndent, "<", resTag, ">",
                                                xmlBodyText,
                                                "</", resTag, ">" ]

        out += [ nl, indent, "</", selfTag, ">" ]
        return "".join(out)

    def __lookup(self,sub):
        for k,vlist in self.__tokdict.items():
            for v,loc in vlist:
                if sub is v:
                    return k
        return None

    def getName(self):
        """Returns the results name for this token expression."""
        if self.__name:
            return self.__name
        elif self.__parent:
            par = self.__parent()
            if par:
                return par.__lookup(self)
            else:
                return None
        elif (len(self) == 1 and
               len(self.__tokdict) == 1 and
               self.__tokdict.values()[0][0][1] in (0,-1)):
            return self.__tokdict.keys()[0]
        else:
            return None

    def dump(self,indent='',depth=0):
        """Diagnostic method for listing out the contents of a C{ParseResults}.
           Accepts an optional C{indent} argument so that this string can be embedded
           in a nested display of other data."""
        out = []
        NL = '\n'
        out.append( indent+_ustr(self.asList()) )
        items = sorted(self.items())
        for k,v in items:
            if out:
                out.append(NL)
            out.append( "%s%s- %s: " % (indent,('  '*depth), k) )
            if isinstance(v,ParseResults):
                if v:
                    if v.haskeys():
                        out.append( v.dump(indent,depth+1) )
                    elif any(isinstance(vv,ParseResults) for vv in v):
                        for i,vv in enumerate(v):
                            if isinstance(vv,ParseResults):
                                out.append("\n%s%s[%d]:\n%s%s%s" % (indent,('  '*(depth+1)),i,indent,('  '*(depth+2)),vv.dump(indent,depth+2) ))
                            else:
                                out.append("\n%s%s[%d]:\n%s%s%s" % (indent,('  '*(depth+1)),i,indent,('  '*(depth+2)),_ustr(vv)))
                    else:
                        out.append(_ustr(v))
                else:
                    out.append(_ustr(v))
            else:
                out.append(_ustr(v))
        return "".join(out)

    def pprint(self, *args, **kwargs):
        """Pretty-printer for parsed results as a list, using the C{pprint} module.
           Accepts additional positional or keyword args as defined for the
           C{pprint.pprint} method. (U{http://docs.python.org/3/library/pprint.html#pprint.pprint})"""
        pprint.pprint(self.asList(), *args, **kwargs)

    # add support for pickle protocol
    def __getstate__(self):
        return ( self.__toklist,
                 ( self.__tokdict.copy(),
                   self.__parent is not None and self.__parent() or None,
                   self.__accumNames,
                   self.__name ) )

    def __setstate__(self,state):
        self.__toklist = state[0]
        (self.__tokdict,
         par,
         inAccumNames,
         self.__name) = state[1]
        self.__accumNames = {}
        self.__accumNames.update(inAccumNames)
        if par is not None:
            self.__parent = wkref(par)
        else:
            self.__parent = None

    def __dir__(self):
        return dir(super(ParseResults,self)) + list(self.keys())

collections.MutableMapping.register(ParseResults)

def col (loc,strg):
    """Returns current column within a string, counting newlines as line separators.
   The first column is number 1.

   Note: the default parsing behavior is to expand tabs in the input string
   before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information
   on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
   consistent view of the parsed string, the parse location, and line and column
   positions within the parsed string.
   """
    return (loc<len(strg) and strg[loc] == '\n') and 1 or loc - strg.rfind("\n", 0, loc)

def lineno(loc,strg):
    """Returns current line number within a string, counting newlines as line separators.
   The first line is number 1.

   Note: the default parsing behavior is to expand tabs in the input string
   before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information
   on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
   consistent view of the parsed string, the parse location, and line and column
   positions within the parsed string.
   """
    return strg.count("\n",0,loc) + 1

def line( loc, strg ):
    """Returns the line of text containing loc within a string, counting newlines as line separators.
       """
    lastCR = strg.rfind("\n", 0, loc)
    nextCR = strg.find("\n", loc)
    if nextCR >= 0:
        return strg[lastCR+1:nextCR]
    else:
        return strg[lastCR+1:]

def _defaultStartDebugAction( instring, loc, expr ):
    print (("Match " + _ustr(expr) + " at loc " + _ustr(loc) + "(%d,%d)" % ( lineno(loc,instring), col(loc,instring) )))

def _defaultSuccessDebugAction( instring, startloc, endloc, expr, toks ):
    print ("Matched " + _ustr(expr) + " -> " + str(toks.asList()))

def _defaultExceptionDebugAction( instring, loc, expr, exc ):
    print ("Exception raised:" + _ustr(exc))

def nullDebugAction(*args):
    """'Do-nothing' debug action, to suppress debugging output during parsing."""
    pass

# Only works on Python 3.x - nonlocal is toxic to Python 2 installs
#~ 'decorator to trim function calls to match the arity of the target'
#~ def _trim_arity(func, maxargs=3):
    #~ if func in singleArgBuiltins:
        #~ return lambda s,l,t: func(t)
    #~ limit = 0
    #~ foundArity = False
    #~ def wrapper(*args):
        #~ nonlocal limit,foundArity
        #~ while 1:
            #~ try:
                #~ ret = func(*args[limit:])
                #~ foundArity = True
                #~ return ret
            #~ except TypeError:
                #~ if limit == maxargs or foundArity:
                    #~ raise
                #~ limit += 1
                #~ continue
    #~ return wrapper

# this version is Python 2.x-3.x cross-compatible
'decorator to trim function calls to match the arity of the target'
def _trim_arity(func, maxargs=2):
    if func in singleArgBuiltins:
        return lambda s,l,t: func(t)
    limit = [0]
    foundArity = [False]
    def wrapper(*args):
        while 1:
            try:
                ret = func(*args[limit[0]:])
                foundArity[0] = True
                return ret
            except TypeError:
                if limit[0] <= maxargs and not foundArity[0]:
                    limit[0] += 1
                    continue
                raise
    return wrapper

class ParserElement(object):
    """Abstract base level parser element class."""
    DEFAULT_WHITE_CHARS = " \n\t\r"
    verbose_stacktrace = False

    def setDefaultWhitespaceChars( chars ):
        """Overrides the default whitespace chars
        """
        ParserElement.DEFAULT_WHITE_CHARS = chars
    setDefaultWhitespaceChars = staticmethod(setDefaultWhitespaceChars)

    def inlineLiteralsUsing(cls):
        """
        Set class to be used for inclusion of string literals into a parser.
        """
        ParserElement.literalStringClass = cls
    inlineLiteralsUsing = staticmethod(inlineLiteralsUsing)

    def __init__( self, savelist=False ):
        self.parseAction = list()
        self.failAction = None
        #~ self.name = "<unknown>"  # don't define self.name, let subclasses try/except upcall
        self.strRepr = None
        self.resultsName = None
        self.saveAsList = savelist
        self.skipWhitespace = True
        self.whiteChars = ParserElement.DEFAULT_WHITE_CHARS
        self.copyDefaultWhiteChars = True
        self.mayReturnEmpty = False # used when checking for left-recursion
        self.keepTabs = False
        self.ignoreExprs = list()
        self.debug = False
        self.streamlined = False
        self.mayIndexError = True # used to optimize exception handling for subclasses that don't advance parse index
        self.errmsg = ""
        self.modalResults = True # used to mark results names as modal (report only last) or cumulative (list all)
        self.debugActions = ( None, None, None ) #custom debug actions
        self.re = None
        self.callPreparse = True # used to avoid redundant calls to preParse
        self.callDuringTry = False

    def copy( self ):
        """Make a copy of this C{ParserElement}.  Useful for defining different parse actions
           for the same parsing pattern, using copies of the original parse element."""
        cpy = copy.copy( self )
        cpy.parseAction = self.parseAction[:]
        cpy.ignoreExprs = self.ignoreExprs[:]
        if self.copyDefaultWhiteChars:
            cpy.whiteChars = ParserElement.DEFAULT_WHITE_CHARS
        return cpy

    def setName( self, name ):
        """Define name for this expression, for use in debugging."""
        self.name = name
        self.errmsg = "Expected " + self.name
        if hasattr(self,"exception"):
            self.exception.msg = self.errmsg
        return self

    def setResultsName( self, name, listAllMatches=False ):
        """Define name for referencing matching tokens as a nested attribute
           of the returned parse results.
           NOTE: this returns a *copy* of the original C{ParserElement} object;
           this is so that the client can define a basic element, such as an
           integer, and reference it in multiple places with different names.

           You can also set results names using the abbreviated syntax,
           C{expr("name")} in place of C{expr.setResultsName("name")} -
           see L{I{__call__}<__call__>}.
        """
        newself = self.copy()
        if name.endswith("*"):
            name = name[:-1]
            listAllMatches=True
        newself.resultsName = name
        newself.modalResults = not listAllMatches
        return newself

    def setBreak(self,breakFlag = True):
        """Method to invoke the Python pdb debugger when this element is
           about to be parsed. Set C{breakFlag} to True to enable, False to
           disable.
        """
        if breakFlag:
            _parseMethod = self._parse
            def breaker(instring, loc, doActions=True, callPreParse=True):
                import pdb
                pdb.set_trace()
                return _parseMethod( instring, loc, doActions, callPreParse )
            breaker._originalParseMethod = _parseMethod
            self._parse = breaker
        else:
            if hasattr(self._parse,"_originalParseMethod"):
                self._parse = self._parse._originalParseMethod
        return self

    def setParseAction( self, *fns, **kwargs ):
        """Define action to perform when successfully matching parse element definition.
           Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
           C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
            - s   = the original string being parsed (see note below)
            - loc = the location of the matching substring
            - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
           If the functions in fns modify the tokens, they can return them as the return
           value from fn, and the modified list of tokens will replace the original.
           Otherwise, fn does not need to return any value.

           Note: the default parsing behavior is to expand tabs in the input string
           before starting the parsing process.  See L{I{parseString}<parseString>} for more information
           on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
           consistent view of the parsed string, the parse location, and line and column
           positions within the parsed string.
           """
        self.parseAction = list(map(_trim_arity, list(fns)))
        self.callDuringTry = ("callDuringTry" in kwargs and kwargs["callDuringTry"])
        return self

    def addParseAction( self, *fns, **kwargs ):
        """Add parse action to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}."""
        self.parseAction += list(map(_trim_arity, list(fns)))
        self.callDuringTry = self.callDuringTry or ("callDuringTry" in kwargs and kwargs["callDuringTry"])
        return self

    def setFailAction( self, fn ):
        """Define action to perform if parsing fails at this expression.
           Fail acton fn is a callable function that takes the arguments
           C{fn(s,loc,expr,err)} where:
            - s = string being parsed
            - loc = location where expression match was attempted and failed
            - expr = the parse expression that failed
            - err = the exception thrown
           The function returns no value.  It may throw C{L{ParseFatalException}}
           if it is desired to stop parsing immediately."""
        self.failAction = fn
        return self

    def _skipIgnorables( self, instring, loc ):
        exprsFound = True
        while exprsFound:
            exprsFound = False
            for e in self.ignoreExprs:
                try:
                    while 1:
                        loc,dummy = e._parse( instring, loc )
                        exprsFound = True
                except ParseException:
                    pass
        return loc

    def preParse( self, instring, loc ):
        if self.ignoreExprs:
            loc = self._skipIgnorables( instring, loc )

        if self.skipWhitespace:
            wt = self.whiteChars
            instrlen = len(instring)
            while loc < instrlen and instring[loc] in wt:
                loc += 1

        return loc

    def parseImpl( self, instring, loc, doActions=True ):
        return loc, []

    def postParse( self, instring, loc, tokenlist ):
        return tokenlist

    #~ @profile
    def _parseNoCache( self, instring, loc, doActions=True, callPreParse=True ):
        debugging = ( self.debug ) #and doActions )

        if debugging or self.failAction:
            #~ print ("Match",self,"at loc",loc,"(%d,%d)" % ( lineno(loc,instring), col(loc,instring) ))
            if (self.debugActions[0] ):
                self.debugActions[0]( instring, loc, self )
            if callPreParse and self.callPreparse:
                preloc = self.preParse( instring, loc )
            else:
                preloc = loc
            tokensStart = preloc
            try:
                try:
                    loc,tokens = self.parseImpl( instring, preloc, doActions )
                except IndexError:
                    raise ParseException( instring, len(instring), self.errmsg, self )
            except ParseBaseException as err:
                #~ print ("Exception raised:", err)
                if self.debugActions[2]:
                    self.debugActions[2]( instring, tokensStart, self, err )
                if self.failAction:
                    self.failAction( instring, tokensStart, self, err )
                raise
        else:
            if callPreParse and self.callPreparse:
                preloc = self.preParse( instring, loc )
            else:
                preloc = loc
            tokensStart = preloc
            if self.mayIndexError or loc >= len(instring):
                try:
                    loc,tokens = self.parseImpl( instring, preloc, doActions )
                except IndexError:
                    raise ParseException( instring, len(instring), self.errmsg, self )
            else:
                loc,tokens = self.parseImpl( instring, preloc, doActions )

        tokens = self.postParse( instring, loc, tokens )

        retTokens = ParseResults( tokens, self.resultsName, asList=self.saveAsList, modal=self.modalResults )
        if self.parseAction and (doActions or self.callDuringTry):
            if debugging:
                try:
                    for fn in self.parseAction:
                        tokens = fn( instring, tokensStart, retTokens )
                        if tokens is not None:
                            retTokens = ParseResults( tokens,
                                                      self.resultsName,
                                                      asList=self.saveAsList and isinstance(tokens,(ParseResults,list)),
                                                      modal=self.modalResults )
                except ParseBaseException as err:
                    #~ print "Exception raised in user parse action:", err
                    if (self.debugActions[2] ):
                        self.debugActions[2]( instring, tokensStart, self, err )
                    raise
            else:
                for fn in self.parseAction:
                    tokens = fn( instring, tokensStart, retTokens )
                    if tokens is not None:
                        retTokens = ParseResults( tokens,
                                                  self.resultsName,
                                                  asList=self.saveAsList and isinstance(tokens,(ParseResults,list)),
                                                  modal=self.modalResults )

        if debugging:
            #~ print ("Matched",self,"->",retTokens.asList())
            if (self.debugActions[1] ):
                self.debugActions[1]( instring, tokensStart, loc, self, retTokens )

        return loc, retTokens

    def tryParse( self, instring, loc ):
        try:
            return self._parse( instring, loc, doActions=False )[0]
        except ParseFatalException:
            raise ParseException( instring, loc, self.errmsg, self)

    # this method gets repeatedly called during backtracking with the same arguments -
    # we can cache these arguments and save ourselves the trouble of re-parsing the contained expression
    def _parseCache( self, instring, loc, doActions=True, callPreParse=True ):
        lookup = (self,instring,loc,callPreParse,doActions)
        if lookup in ParserElement._exprArgCache:
            value = ParserElement._exprArgCache[ lookup ]
            if isinstance(value, Exception):
                raise value
            return (value[0],value[1].copy())
        else:
            try:
                value = self._parseNoCache( instring, loc, doActions, callPreParse )
                ParserElement._exprArgCache[ lookup ] = (value[0],value[1].copy())
                return value
            except ParseBaseException as pe:
                pe.__traceback__ = None
                ParserElement._exprArgCache[ lookup ] = pe
                raise

    _parse = _parseNoCache

    # argument cache for optimizing repeated calls when backtracking through recursive expressions
    _exprArgCache = {}
    def resetCache():
        ParserElement._exprArgCache.clear()
    resetCache = staticmethod(resetCache)

    _packratEnabled = False
    def enablePackrat():
        """Enables "packrat" parsing, which adds memoizing to the parsing logic.
           Repeated parse attempts at the same string location (which happens
           often in many complex grammars) can immediately return a cached value,
           instead of re-executing parsing/validating code.  Memoizing is done of
           both valid results and parsing exceptions.

           This speedup may break existing programs that use parse actions that
           have side-effects.  For this reason, packrat parsing is disabled when
           you first import pyparsing.  To activate the packrat feature, your
           program must call the class method C{ParserElement.enablePackrat()}.  If
           your program uses C{psyco} to "compile as you go", you must call
           C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
           Python will crash.  For best results, call C{enablePackrat()} immediately
           after importing pyparsing.
        """
        if not ParserElement._packratEnabled:
            ParserElement._packratEnabled = True
            ParserElement._parse = ParserElement._parseCache
    enablePackrat = staticmethod(enablePackrat)

    def parseString( self, instring, parseAll=False ):
        """Execute the parse expression with the given string.
           This is the main interface to the client code, once the complete
           expression has been built.

           If you want the grammar to require that the entire input string be
           successfully parsed, then set C{parseAll} to True (equivalent to ending
           the grammar with C{L{StringEnd()}}).

           Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
           in order to report proper column numbers in parse actions.
           If the input string contains tabs and
           the grammar uses parse actions that use the C{loc} argument to index into the
           string being parsed, you can ensure you have a consistent view of the input
           string by:
            - calling C{parseWithTabs} on your grammar before calling C{parseString}
              (see L{I{parseWithTabs}<parseWithTabs>})
            - define your parse action using the full C{(s,loc,toks)} signature, and
              reference the input string using the parse action's C{s} argument
            - explictly expand the tabs in your input string before calling
              C{parseString}
        """
        ParserElement.resetCache()
        if not self.streamlined:
            self.streamline()
            #~ self.saveAsList = True
        for e in self.ignoreExprs:
            e.streamline()
        if not self.keepTabs:
            instring = instring.expandtabs()
        try:
            loc, tokens = self._parse( instring, 0 )
            if parseAll:
                loc = self.preParse( instring, loc )
                se = Empty() + StringEnd()
                se._parse( instring, loc )
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc
        else:
            return tokens

    def scanString( self, instring, maxMatches=_MAX_INT, overlap=False ):
        """Scan the input string for expression matches.  Each match will return the
           matching tokens, start location, and end location.  May be called with optional
           C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
           C{overlap} is specified, then overlapping matches will be reported.

           Note that the start and end locations are reported relative to the string
           being parsed.  See L{I{parseString}<parseString>} for more information on parsing
           strings with embedded tabs."""
        if not self.streamlined:
            self.streamline()
        for e in self.ignoreExprs:
            e.streamline()

        if not self.keepTabs:
            instring = _ustr(instring).expandtabs()
        instrlen = len(instring)
        loc = 0
        preparseFn = self.preParse
        parseFn = self._parse
        ParserElement.resetCache()
        matches = 0
        try:
            while loc <= instrlen and matches < maxMatches:
                try:
                    preloc = preparseFn( instring, loc )
                    nextLoc,tokens = parseFn( instring, preloc, callPreParse=False )
                except ParseException:
                    loc = preloc+1
                else:
                    if nextLoc > loc:
                        matches += 1
                        yield tokens, preloc, nextLoc
                        if overlap:
                            nextloc = preparseFn( instring, loc )
                            if nextloc > loc:
                                loc = nextLoc
                            else:
                                loc += 1
                        else:
                            loc = nextLoc
                    else:
                        loc = preloc+1
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def transformString( self, instring ):
        """Extension to C{L{scanString}}, to modify matching text with modified tokens that may
           be returned from a parse action.  To use C{transformString}, define a grammar and
           attach a parse action to it that modifies the returned token list.
           Invoking C{transformString()} on a target string will then scan for matches,
           and replace the matched text patterns according to the logic in the parse
           action.  C{transformString()} returns the resulting transformed string."""
        out = []
        lastE = 0
        # force preservation of <TAB>s, to minimize unwanted transformation of string, and to
        # keep string locs straight between transformString and scanString
        self.keepTabs = True
        try:
            for t,s,e in self.scanString( instring ):
                out.append( instring[lastE:s] )
                if t:
                    if isinstance(t,ParseResults):
                        out += t.asList()
                    elif isinstance(t,list):
                        out += t
                    else:
                        out.append(t)
                lastE = e
            out.append(instring[lastE:])
            out = [o for o in out if o]
            return "".join(map(_ustr,_flatten(out)))
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def searchString( self, instring, maxMatches=_MAX_INT ):
        """Another extension to C{L{scanString}}, simplifying the access to the tokens found
           to match the given parse expression.  May be called with optional
           C{maxMatches} argument, to clip searching after 'n' matches are found.
        """
        try:
            return ParseResults([ t for t,s,e in self.scanString( instring, maxMatches ) ])
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def __add__(self, other ):
        """Implementation of + operator - returns C{L{And}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return And( [ self, other ] )

    def __radd__(self, other ):
        """Implementation of + operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other + self

    def __sub__(self, other):
        """Implementation of - operator, returns C{L{And}} with error stop"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return And( [ self, And._ErrorStop(), other ] )

    def __rsub__(self, other ):
        """Implementation of - operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other - self

    def __mul__(self,other):
        """Implementation of * operator, allows use of C{expr * 3} in place of
           C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
           tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
           may also include C{None} as in:
            - C{expr*(n,None)} or C{expr*(n,)} is equivalent
              to C{expr*n + L{ZeroOrMore}(expr)}
              (read as "at least n instances of C{expr}")
            - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
              (read as "0 to n instances of C{expr}")
            - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
            - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}

           Note that C{expr*(None,n)} does not raise an exception if
           more than n exprs exist in the input stream; that is,
           C{expr*(None,n)} does not enforce a maximum number of expr
           occurrences.  If this behavior is desired, then write
           C{expr*(None,n) + ~expr}

        """
        if isinstance(other,int):
            minElements, optElements = other,0
        elif isinstance(other,tuple):
            other = (other + (None, None))[:2]
            if other[0] is None:
                other = (0, other[1])
            if isinstance(other[0],int) and other[1] is None:
                if other[0] == 0:
                    return ZeroOrMore(self)
                if other[0] == 1:
                    return OneOrMore(self)
                else:
                    return self*other[0] + ZeroOrMore(self)
            elif isinstance(other[0],int) and isinstance(other[1],int):
                minElements, optElements = other
                optElements -= minElements
            else:
                raise TypeError("cannot multiply 'ParserElement' and ('%s','%s') objects", type(other[0]),type(other[1]))
        else:
            raise TypeError("cannot multiply 'ParserElement' and '%s' objects", type(other))

        if minElements < 0:
            raise ValueError("cannot multiply ParserElement by negative value")
        if optElements < 0:
            raise ValueError("second tuple value must be greater or equal to first tuple value")
        if minElements == optElements == 0:
            raise ValueError("cannot multiply ParserElement by 0 or (0,0)")

        if (optElements):
            def makeOptionalList(n):
                if n>1:
                    return Optional(self + makeOptionalList(n-1))
                else:
                    return Optional(self)
            if minElements:
                if minElements == 1:
                    ret = self + makeOptionalList(optElements)
                else:
                    ret = And([self]*minElements) + makeOptionalList(optElements)
            else:
                ret = makeOptionalList(optElements)
        else:
            if minElements == 1:
                ret = self
            else:
                ret = And([self]*minElements)
        return ret

    def __rmul__(self, other):
        return self.__mul__(other)

    def __or__(self, other ):
        """Implementation of | operator - returns C{L{MatchFirst}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return MatchFirst( [ self, other ] )

    def __ror__(self, other ):
        """Implementation of | operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other | self

    def __xor__(self, other ):
        """Implementation of ^ operator - returns C{L{Or}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return Or( [ self, other ] )

    def __rxor__(self, other ):
        """Implementation of ^ operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other ^ self

    def __and__(self, other ):
        """Implementation of & operator - returns C{L{Each}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return Each( [ self, other ] )

    def __rand__(self, other ):
        """Implementation of & operator when left operand is not a C{L{ParserElement}}"""
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other & self

    def __invert__( self ):
        """Implementation of ~ operator - returns C{L{NotAny}}"""
        return NotAny( self )

    def __call__(self, name=None):
        """Shortcut for C{L{setResultsName}}, with C{listAllMatches=default}::
             userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
           could be written as::
             userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")

           If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
           passed as C{True}.

           If C{name} is omitted, same as calling C{L{copy}}.
           """
        if name is not None:
            return self.setResultsName(name)
        else:
            return self.copy()

    def suppress( self ):
        """Suppresses the output of this C{ParserElement}; useful to keep punctuation from
           cluttering up returned output.
        """
        return Suppress( self )

    def leaveWhitespace( self ):
        """Disables the skipping of whitespace before matching the characters in the
           C{ParserElement}'s defined pattern.  This is normally only used internally by
           the pyparsing module, but may be needed in some whitespace-sensitive grammars.
        """
        self.skipWhitespace = False
        return self

    def setWhitespaceChars( self, chars ):
        """Overrides the default whitespace chars
        """
        self.skipWhitespace = True
        self.whiteChars = chars
        self.copyDefaultWhiteChars = False
        return self

    def parseWithTabs( self ):
        """Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
           Must be called before C{parseString} when the input grammar contains elements that
           match C{<TAB>} characters."""
        self.keepTabs = True
        return self

    def ignore( self, other ):
        """Define expression to be ignored (e.g., comments) while doing pattern
           matching; may be called repeatedly, to define multiple comment or other
           ignorable patterns.
        """
        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                self.ignoreExprs.append( other.copy() )
        else:
            self.ignoreExprs.append( Suppress( other.copy() ) )
        return self

    def setDebugActions( self, startAction, successAction, exceptionAction ):
        """Enable display of debugging messages while doing pattern matching."""
        self.debugActions = (startAction or _defaultStartDebugAction,
                             successAction or _defaultSuccessDebugAction,
                             exceptionAction or _defaultExceptionDebugAction)
        self.debug = True
        return self

    def setDebug( self, flag=True ):
        """Enable display of debugging messages while doing pattern matching.
           Set C{flag} to True to enable, False to disable."""
        if flag:
            self.setDebugActions( _defaultStartDebugAction, _defaultSuccessDebugAction, _defaultExceptionDebugAction )
        else:
            self.debug = False
        return self

    def __str__( self ):
        return self.name

    def __repr__( self ):
        return _ustr(self)

    def streamline( self ):
        self.streamlined = True
        self.strRepr = None
        return self

    def checkRecursion( self, parseElementList ):
        pass

    def validate( self, validateTrace=[] ):
        """Check defined expressions for valid structure, check for infinite recursive definitions."""
        self.checkRecursion( [] )

    def parseFile( self, file_or_filename, parseAll=False ):
        """Execute the parse expression on the given file or filename.
           If a filename is specified (instead of a file object),
           the entire file is opened, read, and closed before parsing.
        """
        try:
            file_contents = file_or_filename.read()
        except AttributeError:
            f = open(file_or_filename, "r")
            file_contents = f.read()
            f.close()
        try:
            return self.parseString(file_contents, parseAll)
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def __eq__(self,other):
        if isinstance(other, ParserElement):
            return self is other or self.__dict__ == other.__dict__
        elif isinstance(other, basestring):
            try:
                self.parseString(_ustr(other), parseAll=True)
                return True
            except ParseBaseException:
                return False
        else:
            return super(ParserElement,self)==other

    def __ne__(self,other):
        return not (self == other)

    def __hash__(self):
        return hash(id(self))

    def __req__(self,other):
        return self == other

    def __rne__(self,other):
        return not (self == other)


class Token(ParserElement):
    """Abstract C{ParserElement} subclass, for defining atomic matching patterns."""
    def __init__( self ):
        super(Token,self).__init__( savelist=False )

    def setName(self, name):
        s = super(Token,self).setName(name)
        self.errmsg = "Expected " + self.name
        return s


class Empty(Token):
    """An empty token, will always match."""
    def __init__( self ):
        super(Empty,self).__init__()
        self.name = "Empty"
        self.mayReturnEmpty = True
        self.mayIndexError = False


class NoMatch(Token):
    """A token that will never match."""
    def __init__( self ):
        super(NoMatch,self).__init__()
        self.name = "NoMatch"
        self.mayReturnEmpty = True
        self.mayIndexError = False
        self.errmsg = "Unmatchable token"

    def parseImpl( self, instring, loc, doActions=True ):
        raise ParseException(instring, loc, self.errmsg, self)


class Literal(Token):
    """Token to exactly match a specified string."""
    def __init__( self, matchString ):
        super(Literal,self).__init__()
        self.match = matchString
        self.matchLen = len(matchString)
        try:
            self.firstMatchChar = matchString[0]
        except IndexError:
            warnings.warn("null string passed to Literal; use Empty() instead",
                            SyntaxWarning, stacklevel=2)
            self.__class__ = Empty
        self.name = '"%s"' % _ustr(self.match)
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = False
        self.mayIndexError = False

    # Performance tuning: this routine gets called a *lot*
    # if this is a single character match string  and the first character matches,
    # short-circuit as quickly as possible, and avoid calling startswith
    #~ @profile
    def parseImpl( self, instring, loc, doActions=True ):
        if (instring[loc] == self.firstMatchChar and
            (self.matchLen==1 or instring.startswith(self.match,loc)) ):
            return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)
_L = Literal
ParserElement.literalStringClass = Literal

class Keyword(Token):
    """Token to exactly match a specified string as a keyword, that is, it must be
       immediately followed by a non-keyword character.  Compare with C{L{Literal}}::
         Literal("if") will match the leading C{'if'} in C{'ifAndOnlyIf'}.
         Keyword("if") will not; it will only match the leading C{'if'} in C{'if x=1'}, or C{'if(y==2)'}
       Accepts two optional constructor arguments in addition to the keyword string:
       C{identChars} is a string of characters that would be valid identifier characters,
       defaulting to all alphanumerics + "_" and "$"; C{caseless} allows case-insensitive
       matching, default is C{False}.
    """
    DEFAULT_KEYWORD_CHARS = alphanums+"_$"

    def __init__( self, matchString, identChars=DEFAULT_KEYWORD_CHARS, caseless=False ):
        super(Keyword,self).__init__()
        self.match = matchString
        self.matchLen = len(matchString)
        try:
            self.firstMatchChar = matchString[0]
        except IndexError:
            warnings.warn("null string passed to Keyword; use Empty() instead",
                            SyntaxWarning, stacklevel=2)
        self.name = '"%s"' % self.match
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = False
        self.mayIndexError = False
        self.caseless = caseless
        if caseless:
            self.caselessmatch = matchString.upper()
            identChars = identChars.upper()
        self.identChars = set(identChars)

    def parseImpl( self, instring, loc, doActions=True ):
        if self.caseless:
            if ( (instring[ loc:loc+self.matchLen ].upper() == self.caselessmatch) and
                 (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen].upper() not in self.identChars) and
                 (loc == 0 or instring[loc-1].upper() not in self.identChars) ):
                return loc+self.matchLen, self.match
        else:
            if (instring[loc] == self.firstMatchChar and
                (self.matchLen==1 or instring.startswith(self.match,loc)) and
                (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen] not in self.identChars) and
                (loc == 0 or instring[loc-1] not in self.identChars) ):
                return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)

    def copy(self):
        c = super(Keyword,self).copy()
        c.identChars = Keyword.DEFAULT_KEYWORD_CHARS
        return c

    def setDefaultKeywordChars( chars ):
        """Overrides the default Keyword chars
        """
        Keyword.DEFAULT_KEYWORD_CHARS = chars
    setDefaultKeywordChars = staticmethod(setDefaultKeywordChars)

class CaselessLiteral(Literal):
    """Token to match a specified string, ignoring case of letters.
       Note: the matched results will always be in the case of the given
       match string, NOT the case of the input text.
    """
    def __init__( self, matchString ):
        super(CaselessLiteral,self).__init__( matchString.upper() )
        # Preserve the defining literal.
        self.returnString = matchString
        self.name = "'%s'" % self.returnString
        self.errmsg = "Expected " + self.name

    def parseImpl( self, instring, loc, doActions=True ):
        if instring[ loc:loc+self.matchLen ].upper() == self.match:
            return loc+self.matchLen, self.returnString
        raise ParseException(instring, loc, self.errmsg, self)

class CaselessKeyword(Keyword):
    def __init__( self, matchString, identChars=Keyword.DEFAULT_KEYWORD_CHARS ):
        super(CaselessKeyword,self).__init__( matchString, identChars, caseless=True )

    def parseImpl( self, instring, loc, doActions=True ):
        if ( (instring[ loc:loc+self.matchLen ].upper() == self.caselessmatch) and
             (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen].upper() not in self.identChars) ):
            return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)

class Word(Token):
    """Token for matching words composed of allowed character sets.
       Defined with string containing all allowed initial characters,
       an optional string containing allowed body characters (if omitted,
       defaults to the initial character set), and an optional minimum,
       maximum, and/or exact length.  The default value for C{min} is 1 (a
       minimum value < 1 is not valid); the default values for C{max} and C{exact}
       are 0, meaning no maximum or exact length restriction. An optional
       C{exclude} parameter can list characters that might be found in
       the input C{bodyChars} string; useful to define a word of all printables
       except for one or two characters, for instance.
    """
    def __init__( self, initChars, bodyChars=None, min=1, max=0, exact=0, asKeyword=False, excludeChars=None ):
        super(Word,self).__init__()
        if excludeChars:
            initChars = ''.join(c for c in initChars if c not in excludeChars)
            if bodyChars:
                bodyChars = ''.join(c for c in bodyChars if c not in excludeChars)
        self.initCharsOrig = initChars
        self.initChars = set(initChars)
        if bodyChars :
            self.bodyCharsOrig = bodyChars
            self.bodyChars = set(bodyChars)
        else:
            self.bodyCharsOrig = initChars
            self.bodyChars = set(initChars)

        self.maxSpecified = max > 0

        if min < 1:
            raise ValueError("cannot specify a minimum length < 1; use Optional(Word()) if zero-length word is permitted")

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.asKeyword = asKeyword

        if ' ' not in self.initCharsOrig+self.bodyCharsOrig and (min==1 and max==0 and exact==0):
            if self.bodyCharsOrig == self.initCharsOrig:
                self.reString = "[%s]+" % _escapeRegexRangeChars(self.initCharsOrig)
            elif len(self.bodyCharsOrig) == 1:
                self.reString = "%s[%s]*" % \
                                      (re.escape(self.initCharsOrig),
                                      _escapeRegexRangeChars(self.bodyCharsOrig),)
            else:
                self.reString = "[%s][%s]*" % \
                                      (_escapeRegexRangeChars(self.initCharsOrig),
                                      _escapeRegexRangeChars(self.bodyCharsOrig),)
            if self.asKeyword:
                self.reString = r"\b"+self.reString+r"\b"
            try:
                self.re = re.compile( self.reString )
            except:
                self.re = None

    def parseImpl( self, instring, loc, doActions=True ):
        if self.re:
            result = self.re.match(instring,loc)
            if not result:
                raise ParseException(instring, loc, self.errmsg, self)

            loc = result.end()
            return loc, result.group()

        if not(instring[ loc ] in self.initChars):
            raise ParseException(instring, loc, self.errmsg, self)

        start = loc
        loc += 1
        instrlen = len(instring)
        bodychars = self.bodyChars
        maxloc = start + self.maxLen
        maxloc = min( maxloc, instrlen )
        while loc < maxloc and instring[loc] in bodychars:
            loc += 1

        throwException = False
        if loc - start < self.minLen:
            throwException = True
        if self.maxSpecified and loc < instrlen and instring[loc] in bodychars:
            throwException = True
        if self.asKeyword:
            if (start>0 and instring[start-1] in bodychars) or (loc<instrlen and instring[loc] in bodychars):
                throwException = True

        if throwException:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]

    def __str__( self ):
        try:
            return super(Word,self).__str__()
        except:
            pass


        if self.strRepr is None:

            def charsAsStr(s):
                if len(s)>4:
                    return s[:4]+"..."
                else:
                    return s

            if ( self.initCharsOrig != self.bodyCharsOrig ):
                self.strRepr = "W:(%s,%s)" % ( charsAsStr(self.initCharsOrig), charsAsStr(self.bodyCharsOrig) )
            else:
                self.strRepr = "W:(%s)" % charsAsStr(self.initCharsOrig)

        return self.strRepr


class Regex(Token):
    """Token for matching strings that match a given regular expression.
       Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
    """
    compiledREtype = type(re.compile("[A-Z]"))
    def __init__( self, pattern, flags=0):
        """The parameters C{pattern} and C{flags} are passed to the C{re.compile()} function as-is. See the Python C{re} module for an explanation of the acceptable patterns and flags."""
        super(Regex,self).__init__()

        if isinstance(pattern, basestring):
            if len(pattern) == 0:
                warnings.warn("null string passed to Regex; use Empty() instead",
                        SyntaxWarning, stacklevel=2)

            self.pattern = pattern
            self.flags = flags

            try:
                self.re = re.compile(self.pattern, self.flags)
                self.reString = self.pattern
            except sre_constants.error:
                warnings.warn("invalid pattern (%s) passed to Regex" % pattern,
                    SyntaxWarning, stacklevel=2)
                raise

        elif isinstance(pattern, Regex.compiledREtype):
            self.re = pattern
            self.pattern = \
            self.reString = str(pattern)
            self.flags = flags

        else:
            raise ValueError("Regex may only be constructed with a string or a compiled RE object")

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        result = self.re.match(instring,loc)
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        d = result.groupdict()
        ret = ParseResults(result.group())
        if d:
            for k in d:
                ret[k] = d[k]
        return loc,ret

    def __str__( self ):
        try:
            return super(Regex,self).__str__()
        except:
            pass

        if self.strRepr is None:
            self.strRepr = "Re:(%s)" % repr(self.pattern)

        return self.strRepr


class QuotedString(Token):
    """Token for matching strings that are delimited by quoting characters.
    """
    def __init__( self, quoteChar, escChar=None, escQuote=None, multiline=False, unquoteResults=True, endQuoteChar=None):
        """
           Defined with the following parameters:
            - quoteChar - string of one or more characters defining the quote delimiting string
            - escChar - character to escape quotes, typically backslash (default=None)
            - escQuote - special quote sequence to escape an embedded quote string (such as SQL's "" to escape an embedded ") (default=None)
            - multiline - boolean indicating whether quotes can span multiple lines (default=C{False})
            - unquoteResults - boolean indicating whether the matched text should be unquoted (default=C{True})
            - endQuoteChar - string of one or more characters defining the end of the quote delimited string (default=C{None} => same as quoteChar)
        """
        super(QuotedString,self).__init__()

        # remove white space from quote chars - wont work anyway
        quoteChar = quoteChar.strip()
        if len(quoteChar) == 0:
            warnings.warn("quoteChar cannot be the empty string",SyntaxWarning,stacklevel=2)
            raise SyntaxError()

        if endQuoteChar is None:
            endQuoteChar = quoteChar
        else:
            endQuoteChar = endQuoteChar.strip()
            if len(endQuoteChar) == 0:
                warnings.warn("endQuoteChar cannot be the empty string",SyntaxWarning,stacklevel=2)
                raise SyntaxError()

        self.quoteChar = quoteChar
        self.quoteCharLen = len(quoteChar)
        self.firstQuoteChar = quoteChar[0]
        self.endQuoteChar = endQuoteChar
        self.endQuoteCharLen = len(endQuoteChar)
        self.escChar = escChar
        self.escQuote = escQuote
        self.unquoteResults = unquoteResults

        if multiline:
            self.flags = re.MULTILINE | re.DOTALL
            self.pattern = r'%s(?:[^%s%s]' % \
                ( re.escape(self.quoteChar),
                  _escapeRegexRangeChars(self.endQuoteChar[0]),
                  (escChar is not None and _escapeRegexRangeChars(escChar) or '') )
        else:
            self.flags = 0
            self.pattern = r'%s(?:[^%s\n\r%s]' % \
                ( re.escape(self.quoteChar),
                  _escapeRegexRangeChars(self.endQuoteChar[0]),
                  (escChar is not None and _escapeRegexRangeChars(escChar) or '') )
        if len(self.endQuoteChar) > 1:
            self.pattern += (
                '|(?:' + ')|(?:'.join("%s[^%s]" % (re.escape(self.endQuoteChar[:i]),
                                               _escapeRegexRangeChars(self.endQuoteChar[i]))
                                    for i in range(len(self.endQuoteChar)-1,0,-1)) + ')'
                )
        if escQuote:
            self.pattern += (r'|(?:%s)' % re.escape(escQuote))
        if escChar:
            self.pattern += (r'|(?:%s.)' % re.escape(escChar))
            self.escCharReplacePattern = re.escape(self.escChar)+"(.)"
        self.pattern += (r')*%s' % re.escape(self.endQuoteChar))

        try:
            self.re = re.compile(self.pattern, self.flags)
            self.reString = self.pattern
        except sre_constants.error:
            warnings.warn("invalid pattern (%s) passed to Regex" % self.pattern,
                SyntaxWarning, stacklevel=2)
            raise

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        result = instring[loc] == self.firstQuoteChar and self.re.match(instring,loc) or None
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        ret = result.group()

        if self.unquoteResults:

            # strip off quotes
            ret = ret[self.quoteCharLen:-self.endQuoteCharLen]

            if isinstance(ret,basestring):
                # replace escaped characters
                if self.escChar:
                    ret = re.sub(self.escCharReplacePattern,"\g<1>",ret)

                # replace escaped quotes
                if self.escQuote:
                    ret = ret.replace(self.escQuote, self.endQuoteChar)

        return loc, ret

    def __str__( self ):
        try:
            return super(QuotedString,self).__str__()
        except:
            pass

        if self.strRepr is None:
            self.strRepr = "quoted string, starting with %s ending with %s" % (self.quoteChar, self.endQuoteChar)

        return self.strRepr


class CharsNotIn(Token):
    """Token for matching words composed of characters *not* in a given set.
       Defined with string containing all disallowed characters, and an optional
       minimum, maximum, and/or exact length.  The default value for C{min} is 1 (a
       minimum value < 1 is not valid); the default values for C{max} and C{exact}
       are 0, meaning no maximum or exact length restriction.
    """
    def __init__( self, notChars, min=1, max=0, exact=0 ):
        super(CharsNotIn,self).__init__()
        self.skipWhitespace = False
        self.notChars = notChars

        if min < 1:
            raise ValueError("cannot specify a minimum length < 1; use Optional(CharsNotIn()) if zero-length char group is permitted")

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = ( self.minLen == 0 )
        self.mayIndexError = False

    def parseImpl( self, instring, loc, doActions=True ):
        if instring[loc] in self.notChars:
            raise ParseException(instring, loc, self.errmsg, self)

        start = loc
        loc += 1
        notchars = self.notChars
        maxlen = min( start+self.maxLen, len(instring) )
        while loc < maxlen and \
              (instring[loc] not in notchars):
            loc += 1

        if loc - start < self.minLen:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]

    def __str__( self ):
        try:
            return super(CharsNotIn, self).__str__()
        except:
            pass

        if self.strRepr is None:
            if len(self.notChars) > 4:
                self.strRepr = "!W:(%s...)" % self.notChars[:4]
            else:
                self.strRepr = "!W:(%s)" % self.notChars

        return self.strRepr

class White(Token):
    """Special matching class for matching whitespace.  Normally, whitespace is ignored
       by pyparsing grammars.  This class is included when some whitespace structures
       are significant.  Define with a string containing the whitespace characters to be
       matched; default is C{" \\t\\r\\n"}.  Also takes optional C{min}, C{max}, and C{exact} arguments,
       as defined for the C{L{Word}} class."""
    whiteStrs = {
        " " : "<SPC>",
        "\t": "<TAB>",
        "\n": "<LF>",
        "\r": "<CR>",
        "\f": "<FF>",
        }
    def __init__(self, ws=" \t\r\n", min=1, max=0, exact=0):
        super(White,self).__init__()
        self.matchWhite = ws
        self.setWhitespaceChars( "".join(c for c in self.whiteChars if c not in self.matchWhite) )
        #~ self.leaveWhitespace()
        self.name = ("".join(White.whiteStrs[c] for c in self.matchWhite))
        self.mayReturnEmpty = True
        self.errmsg = "Expected " + self.name

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

    def parseImpl( self, instring, loc, doActions=True ):
        if not(instring[ loc ] in self.matchWhite):
            raise ParseException(instring, loc, self.errmsg, self)
        start = loc
        loc += 1
        maxloc = start + self.maxLen
        maxloc = min( maxloc, len(instring) )
        while loc < maxloc and instring[loc] in self.matchWhite:
            loc += 1

        if loc - start < self.minLen:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]


class _PositionToken(Token):
    def __init__( self ):
        super(_PositionToken,self).__init__()
        self.name=self.__class__.__name__
        self.mayReturnEmpty = True
        self.mayIndexError = False

class GoToColumn(_PositionToken):
    """Token to advance to a specific column of input text; useful for tabular report scraping."""
    def __init__( self, colno ):
        super(GoToColumn,self).__init__()
        self.col = colno

    def preParse( self, instring, loc ):
        if col(loc,instring) != self.col:
            instrlen = len(instring)
            if self.ignoreExprs:
                loc = self._skipIgnorables( instring, loc )
            while loc < instrlen and instring[loc].isspace() and col( loc, instring ) != self.col :
                loc += 1
        return loc

    def parseImpl( self, instring, loc, doActions=True ):
        thiscol = col( loc, instring )
        if thiscol > self.col:
            raise ParseException( instring, loc, "Text not in expected column", self )
        newloc = loc + self.col - thiscol
        ret = instring[ loc: newloc ]
        return newloc, ret

class LineStart(_PositionToken):
    """Matches if current position is at the beginning of a line within the parse string"""
    def __init__( self ):
        super(LineStart,self).__init__()
        self.setWhitespaceChars( ParserElement.DEFAULT_WHITE_CHARS.replace("\n","") )
        self.errmsg = "Expected start of line"

    def preParse( self, instring, loc ):
        preloc = super(LineStart,self).preParse(instring,loc)
        if instring[preloc] == "\n":
            loc += 1
        return loc

    def parseImpl( self, instring, loc, doActions=True ):
        if not( loc==0 or
            (loc == self.preParse( instring, 0 )) or
            (instring[loc-1] == "\n") ): #col(loc, instring) != 1:
            raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

class LineEnd(_PositionToken):
    """Matches if current position is at the end of a line within the parse string"""
    def __init__( self ):
        super(LineEnd,self).__init__()
        self.setWhitespaceChars( ParserElement.DEFAULT_WHITE_CHARS.replace("\n","") )
        self.errmsg = "Expected end of line"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc<len(instring):
            if instring[loc] == "\n":
                return loc+1, "\n"
            else:
                raise ParseException(instring, loc, self.errmsg, self)
        elif loc == len(instring):
            return loc+1, []
        else:
            raise ParseException(instring, loc, self.errmsg, self)

class StringStart(_PositionToken):
    """Matches if current position is at the beginning of the parse string"""
    def __init__( self ):
        super(StringStart,self).__init__()
        self.errmsg = "Expected start of text"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc != 0:
            # see if entire string up to here is just whitespace and ignoreables
            if loc != self.preParse( instring, 0 ):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

class StringEnd(_PositionToken):
    """Matches if current position is at the end of the parse string"""
    def __init__( self ):
        super(StringEnd,self).__init__()
        self.errmsg = "Expected end of text"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc < len(instring):
            raise ParseException(instring, loc, self.errmsg, self)
        elif loc == len(instring):
            return loc+1, []
        elif loc > len(instring):
            return loc, []
        else:
            raise ParseException(instring, loc, self.errmsg, self)

class WordStart(_PositionToken):
    """Matches if the current position is at the beginning of a Word, and
       is not preceded by any character in a given set of C{wordChars}
       (default=C{printables}). To emulate the C{\b} behavior of regular expressions,
       use C{WordStart(alphanums)}. C{WordStart} will also match at the beginning of
       the string being parsed, or at the beginning of a line.
    """
    def __init__(self, wordChars = printables):
        super(WordStart,self).__init__()
        self.wordChars = set(wordChars)
        self.errmsg = "Not at the start of a word"

    def parseImpl(self, instring, loc, doActions=True ):
        if loc != 0:
            if (instring[loc-1] in self.wordChars or
                instring[loc] not in self.wordChars):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

class WordEnd(_PositionToken):
    """Matches if the current position is at the end of a Word, and
       is not followed by any character in a given set of C{wordChars}
       (default=C{printables}). To emulate the C{\b} behavior of regular expressions,
       use C{WordEnd(alphanums)}. C{WordEnd} will also match at the end of
       the string being parsed, or at the end of a line.
    """
    def __init__(self, wordChars = printables):
        super(WordEnd,self).__init__()
        self.wordChars = set(wordChars)
        self.skipWhitespace = False
        self.errmsg = "Not at the end of a word"

    def parseImpl(self, instring, loc, doActions=True ):
        instrlen = len(instring)
        if instrlen>0 and loc<instrlen:
            if (instring[loc] in self.wordChars or
                instring[loc-1] not in self.wordChars):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []


class ParseExpression(ParserElement):
    """Abstract subclass of ParserElement, for combining and post-processing parsed tokens."""
    def __init__( self, exprs, savelist = False ):
        super(ParseExpression,self).__init__(savelist)
        if isinstance( exprs, _generatorType ):
            exprs = list(exprs)

        if isinstance( exprs, basestring ):
            self.exprs = [ Literal( exprs ) ]
        elif isinstance( exprs, collections.Sequence ):
            # if sequence of strings provided, wrap with Literal
            if all(isinstance(expr, basestring) for expr in exprs):
                exprs = map(Literal, exprs)
            self.exprs = list(exprs)
        else:
            try:
                self.exprs = list( exprs )
            except TypeError:
                self.exprs = [ exprs ]
        self.callPreparse = False

    def __getitem__( self, i ):
        return self.exprs[i]

    def append( self, other ):
        self.exprs.append( other )
        self.strRepr = None
        return self

    def leaveWhitespace( self ):
        """Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
           all contained expressions."""
        self.skipWhitespace = False
        self.exprs = [ e.copy() for e in self.exprs ]
        for e in self.exprs:
            e.leaveWhitespace()
        return self

    def ignore( self, other ):
        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                super( ParseExpression, self).ignore( other )
                for e in self.exprs:
                    e.ignore( self.ignoreExprs[-1] )
        else:
            super( ParseExpression, self).ignore( other )
            for e in self.exprs:
                e.ignore( self.ignoreExprs[-1] )
        return self

    def __str__( self ):
        try:
            return super(ParseExpression,self).__str__()
        except:
            pass

        if self.strRepr is None:
            self.strRepr = "%s:(%s)" % ( self.__class__.__name__, _ustr(self.exprs) )
        return self.strRepr

    def streamline( self ):
        super(ParseExpression,self).streamline()

        for e in self.exprs:
            e.streamline()

        # collapse nested And's of the form And( And( And( a,b), c), d) to And( a,b,c,d )
        # but only if there are no parse actions or resultsNames on the nested And's
        # (likewise for Or's and MatchFirst's)
        if ( len(self.exprs) == 2 ):
            other = self.exprs[0]
            if ( isinstance( other, self.__class__ ) and
                  not(other.parseAction) and
                  other.resultsName is None and
                  not other.debug ):
                self.exprs = other.exprs[:] + [ self.exprs[1] ]
                self.strRepr = None
                self.mayReturnEmpty |= other.mayReturnEmpty
                self.mayIndexError  |= other.mayIndexError

            other = self.exprs[-1]
            if ( isinstance( other, self.__class__ ) and
                  not(other.parseAction) and
                  other.resultsName is None and
                  not other.debug ):
                self.exprs = self.exprs[:-1] + other.exprs[:]
                self.strRepr = None
                self.mayReturnEmpty |= other.mayReturnEmpty
                self.mayIndexError  |= other.mayIndexError

        return self

    def setResultsName( self, name, listAllMatches=False ):
        ret = super(ParseExpression,self).setResultsName(name,listAllMatches)
        return ret

    def validate( self, validateTrace=[] ):
        tmp = validateTrace[:]+[self]
        for e in self.exprs:
            e.validate(tmp)
        self.checkRecursion( [] )

    def copy(self):
        ret = super(ParseExpression,self).copy()
        ret.exprs = [e.copy() for e in self.exprs]
        return ret

class And(ParseExpression):
    """Requires all given C{ParseExpression}s to be found in the given order.
       Expressions may be separated by whitespace.
       May be constructed using the C{'+'} operator.
    """

    class _ErrorStop(Empty):
        def __init__(self, *args, **kwargs):
            super(And._ErrorStop,self).__init__(*args, **kwargs)
            self.name = '-'
            self.leaveWhitespace()

    def __init__( self, exprs, savelist = True ):
        super(And,self).__init__(exprs, savelist)
        self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
        self.setWhitespaceChars( self.exprs[0].whiteChars )
        self.skipWhitespace = self.exprs[0].skipWhitespace
        self.callPreparse = True

    def parseImpl( self, instring, loc, doActions=True ):
        # pass False as last arg to _parse for first element, since we already
        # pre-parsed the string as part of our And pre-parsing
        loc, resultlist = self.exprs[0]._parse( instring, loc, doActions, callPreParse=False )
        errorStop = False
        for e in self.exprs[1:]:
            if isinstance(e, And._ErrorStop):
                errorStop = True
                continue
            if errorStop:
                try:
                    loc, exprtokens = e._parse( instring, loc, doActions )
                except ParseSyntaxException:
                    raise
                except ParseBaseException as pe:
                    pe.__traceback__ = None
                    raise ParseSyntaxException(pe)
                except IndexError:
                    raise ParseSyntaxException( ParseException(instring, len(instring), self.errmsg, self) )
            else:
                loc, exprtokens = e._parse( instring, loc, doActions )
            if exprtokens or exprtokens.haskeys():
                resultlist += exprtokens
        return loc, resultlist

    def __iadd__(self, other ):
        if isinstance( other, basestring ):
            other = Literal( other )
        return self.append( other ) #And( [ self, other ] )

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )
            if not e.mayReturnEmpty:
                break

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr


class Or(ParseExpression):
    """Requires that at least one C{ParseExpression} is found.
       If two expressions match, the expression that matches the longest string will be used.
       May be constructed using the C{'^'} operator.
    """
    def __init__( self, exprs, savelist = False ):
        super(Or,self).__init__(exprs, savelist)
        if self.exprs:
            self.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)
        else:
            self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        maxExcLoc = -1
        maxMatchLoc = -1
        maxException = None
        for e in self.exprs:
            try:
                loc2 = e.tryParse( instring, loc )
            except ParseException as err:
                err.__traceback__ = None
                if err.loc > maxExcLoc:
                    maxException = err
                    maxExcLoc = err.loc
            except IndexError:
                if len(instring) > maxExcLoc:
                    maxException = ParseException(instring,len(instring),e.errmsg,self)
                    maxExcLoc = len(instring)
            else:
                if loc2 > maxMatchLoc:
                    maxMatchLoc = loc2
                    maxMatchExp = e

        if maxMatchLoc < 0:
            if maxException is not None:
                raise maxException
            else:
                raise ParseException(instring, loc, "no defined alternatives to match", self)

        return maxMatchExp._parse( instring, loc, doActions )

    def __ixor__(self, other ):
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        return self.append( other ) #Or( [ self, other ] )

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " ^ ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class MatchFirst(ParseExpression):
    """Requires that at least one C{ParseExpression} is found.
       If two expressions match, the first one listed is the one that will match.
       May be constructed using the C{'|'} operator.
    """
    def __init__( self, exprs, savelist = False ):
        super(MatchFirst,self).__init__(exprs, savelist)
        if self.exprs:
            self.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)
        else:
            self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        maxExcLoc = -1
        maxException = None
        for e in self.exprs:
            try:
                ret = e._parse( instring, loc, doActions )
                return ret
            except ParseException as err:
                if err.loc > maxExcLoc:
                    maxException = err
                    maxExcLoc = err.loc
            except IndexError:
                if len(instring) > maxExcLoc:
                    maxException = ParseException(instring,len(instring),e.errmsg,self)
                    maxExcLoc = len(instring)

        # only got here if no expression matched, raise exception for match that made it the furthest
        else:
            if maxException is not None:
                raise maxException
            else:
                raise ParseException(instring, loc, "no defined alternatives to match", self)

    def __ior__(self, other ):
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass( other )
        return self.append( other ) #MatchFirst( [ self, other ] )

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " | ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class Each(ParseExpression):
    """Requires all given C{ParseExpression}s to be found, but in any order.
       Expressions may be separated by whitespace.
       May be constructed using the C{'&'} operator.
    """
    def __init__( self, exprs, savelist = True ):
        super(Each,self).__init__(exprs, savelist)
        self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
        self.skipWhitespace = True
        self.initExprGroups = True

    def parseImpl( self, instring, loc, doActions=True ):
        if self.initExprGroups:
            opt1 = [ e.expr for e in self.exprs if isinstance(e,Optional) ]
            opt2 = [ e for e in self.exprs if e.mayReturnEmpty and e not in opt1 ]
            self.optionals = opt1 + opt2
            self.multioptionals = [ e.expr for e in self.exprs if isinstance(e,ZeroOrMore) ]
            self.multirequired = [ e.expr for e in self.exprs if isinstance(e,OneOrMore) ]
            self.required = [ e for e in self.exprs if not isinstance(e,(Optional,ZeroOrMore,OneOrMore)) ]
            self.required += self.multirequired
            self.initExprGroups = False
        tmpLoc = loc
        tmpReqd = self.required[:]
        tmpOpt  = self.optionals[:]
        matchOrder = []

        keepMatching = True
        while keepMatching:
            tmpExprs = tmpReqd + tmpOpt + self.multioptionals + self.multirequired
            failed = []
            for e in tmpExprs:
                try:
                    tmpLoc = e.tryParse( instring, tmpLoc )
                except ParseException:
                    failed.append(e)
                else:
                    matchOrder.append(e)
                    if e in tmpReqd:
                        tmpReqd.remove(e)
                    elif e in tmpOpt:
                        tmpOpt.remove(e)
            if len(failed) == len(tmpExprs):
                keepMatching = False

        if tmpReqd:
            missing = ", ".join(_ustr(e) for e in tmpReqd)
            raise ParseException(instring,loc,"Missing one or more required elements (%s)" % missing )

        # add any unmatched Optionals, in case they have default values defined
        matchOrder += [e for e in self.exprs if isinstance(e,Optional) and e.expr in tmpOpt]

        resultlist = []
        for e in matchOrder:
            loc,results = e._parse(instring,loc,doActions)
            resultlist.append(results)

        finalResults = ParseResults([])
        for r in resultlist:
            dups = {}
            for k in r.keys():
                if k in finalResults:
                    tmp = ParseResults(finalResults[k])
                    tmp += ParseResults(r[k])
                    dups[k] = tmp
            finalResults += ParseResults(r)
            for k,v in dups.items():
                finalResults[k] = v
        return loc, finalResults

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " & ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class ParseElementEnhance(ParserElement):
    """Abstract subclass of C{ParserElement}, for combining and post-processing parsed tokens."""
    def __init__( self, expr, savelist=False ):
        super(ParseElementEnhance,self).__init__(savelist)
        if isinstance( expr, basestring ):
            expr = Literal(expr)
        self.expr = expr
        self.strRepr = None
        if expr is not None:
            self.mayIndexError = expr.mayIndexError
            self.mayReturnEmpty = expr.mayReturnEmpty
            self.setWhitespaceChars( expr.whiteChars )
            self.skipWhitespace = expr.skipWhitespace
            self.saveAsList = expr.saveAsList
            self.callPreparse = expr.callPreparse
            self.ignoreExprs.extend(expr.ignoreExprs)

    def parseImpl( self, instring, loc, doActions=True ):
        if self.expr is not None:
            return self.expr._parse( instring, loc, doActions, callPreParse=False )
        else:
            raise ParseException("",loc,self.errmsg,self)

    def leaveWhitespace( self ):
        self.skipWhitespace = False
        self.expr = self.expr.copy()
        if self.expr is not None:
            self.expr.leaveWhitespace()
        return self

    def ignore( self, other ):
        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                super( ParseElementEnhance, self).ignore( other )
                if self.expr is not None:
                    self.expr.ignore( self.ignoreExprs[-1] )
        else:
            super( ParseElementEnhance, self).ignore( other )
            if self.expr is not None:
                self.expr.ignore( self.ignoreExprs[-1] )
        return self

    def streamline( self ):
        super(ParseElementEnhance,self).streamline()
        if self.expr is not None:
            self.expr.streamline()
        return self

    def checkRecursion( self, parseElementList ):
        if self in parseElementList:
            raise RecursiveGrammarException( parseElementList+[self] )
        subRecCheckList = parseElementList[:] + [ self ]
        if self.expr is not None:
            self.expr.checkRecursion( subRecCheckList )

    def validate( self, validateTrace=[] ):
        tmp = validateTrace[:]+[self]
        if self.expr is not None:
            self.expr.validate(tmp)
        self.checkRecursion( [] )

    def __str__( self ):
        try:
            return super(ParseElementEnhance,self).__str__()
        except:
            pass

        if self.strRepr is None and self.expr is not None:
            self.strRepr = "%s:(%s)" % ( self.__class__.__name__, _ustr(self.expr) )
        return self.strRepr


class FollowedBy(ParseElementEnhance):
    """Lookahead matching of the given parse expression.  C{FollowedBy}
    does *not* advance the parsing position within the input string, it only
    verifies that the specified parse expression matches at the current
    position.  C{FollowedBy} always returns a null token list."""
    def __init__( self, expr ):
        super(FollowedBy,self).__init__(expr)
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        self.expr.tryParse( instring, loc )
        return loc, []


class NotAny(ParseElementEnhance):
    """Lookahead to disallow matching with the given parse expression.  C{NotAny}
    does *not* advance the parsing position within the input string, it only
    verifies that the specified parse expression does *not* match at the current
    position.  Also, C{NotAny} does *not* skip over leading whitespace. C{NotAny}
    always returns a null token list.  May be constructed using the '~' operator."""
    def __init__( self, expr ):
        super(NotAny,self).__init__(expr)
        #~ self.leaveWhitespace()
        self.skipWhitespace = False  # do NOT use self.leaveWhitespace(), don't want to propagate to exprs
        self.mayReturnEmpty = True
        self.errmsg = "Found unwanted token, "+_ustr(self.expr)

    def parseImpl( self, instring, loc, doActions=True ):
        try:
            self.expr.tryParse( instring, loc )
        except (ParseException,IndexError):
            pass
        else:
            raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "~{" + _ustr(self.expr) + "}"

        return self.strRepr


class ZeroOrMore(ParseElementEnhance):
    """Optional repetition of zero or more of the given expression."""
    def __init__( self, expr ):
        super(ZeroOrMore,self).__init__(expr)
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        tokens = []
        try:
            loc, tokens = self.expr._parse( instring, loc, doActions, callPreParse=False )
            hasIgnoreExprs = ( len(self.ignoreExprs) > 0 )
            while 1:
                if hasIgnoreExprs:
                    preloc = self._skipIgnorables( instring, loc )
                else:
                    preloc = loc
                loc, tmptokens = self.expr._parse( instring, preloc, doActions )
                if tmptokens or tmptokens.haskeys():
                    tokens += tmptokens
        except (ParseException,IndexError):
            pass

        return loc, tokens

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "[" + _ustr(self.expr) + "]..."

        return self.strRepr

    def setResultsName( self, name, listAllMatches=False ):
        ret = super(ZeroOrMore,self).setResultsName(name,listAllMatches)
        ret.saveAsList = True
        return ret


class OneOrMore(ParseElementEnhance):
    """Repetition of one or more of the given expression."""
    def parseImpl( self, instring, loc, doActions=True ):
        # must be at least one
        loc, tokens = self.expr._parse( instring, loc, doActions, callPreParse=False )
        try:
            hasIgnoreExprs = ( len(self.ignoreExprs) > 0 )
            while 1:
                if hasIgnoreExprs:
                    preloc = self._skipIgnorables( instring, loc )
                else:
                    preloc = loc
                loc, tmptokens = self.expr._parse( instring, preloc, doActions )
                if tmptokens or tmptokens.haskeys():
                    tokens += tmptokens
        except (ParseException,IndexError):
            pass

        return loc, tokens

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + _ustr(self.expr) + "}..."

        return self.strRepr

    def setResultsName( self, name, listAllMatches=False ):
        ret = super(OneOrMore,self).setResultsName(name,listAllMatches)
        ret.saveAsList = True
        return ret

class _NullToken(object):
    def __bool__(self):
        return False
    __nonzero__ = __bool__
    def __str__(self):
        return ""

_optionalNotMatched = _NullToken()
class Optional(ParseElementEnhance):
    """Optional matching of the given expression.
       A default return string can also be specified, if the optional expression
       is not found.
    """
    def __init__( self, expr, default=_optionalNotMatched ):
        super(Optional,self).__init__( expr, savelist=False )
        self.defaultValue = default
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        try:
            loc, tokens = self.expr._parse( instring, loc, doActions, callPreParse=False )
        except (ParseException,IndexError):
            if self.defaultValue is not _optionalNotMatched:
                if self.expr.resultsName:
                    tokens = ParseResults([ self.defaultValue ])
                    tokens[self.expr.resultsName] = self.defaultValue
                else:
                    tokens = [ self.defaultValue ]
            else:
                tokens = []
        return loc, tokens

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "[" + _ustr(self.expr) + "]"

        return self.strRepr


class SkipTo(ParseElementEnhance):
    """Token for skipping over all undefined text until the matched expression is found.
       If C{include} is set to true, the matched expression is also parsed (the skipped text
       and matched expression are returned as a 2-element list).  The C{ignore}
       argument is used to define grammars (typically quoted strings and comments) that
       might contain false matches.
    """
    def __init__( self, other, include=False, ignore=None, failOn=None ):
        super( SkipTo, self ).__init__( other )
        self.ignoreExpr = ignore
        self.mayReturnEmpty = True
        self.mayIndexError = False
        self.includeMatch = include
        self.asList = False
        if failOn is not None and isinstance(failOn, basestring):
            self.failOn = Literal(failOn)
        else:
            self.failOn = failOn
        self.errmsg = "No match found for "+_ustr(self.expr)

    def parseImpl( self, instring, loc, doActions=True ):
        startLoc = loc
        instrlen = len(instring)
        expr = self.expr
        failParse = False
        while loc <= instrlen:
            try:
                if self.failOn:
                    try:
                        self.failOn.tryParse(instring, loc)
                    except ParseBaseException:
                        pass
                    else:
                        failParse = True
                        raise ParseException(instring, loc, "Found expression " + str(self.failOn))
                    failParse = False
                if self.ignoreExpr is not None:
                    while 1:
                        try:
                            loc = self.ignoreExpr.tryParse(instring,loc)
                            # print("found ignoreExpr, advance to", loc)
                        except ParseBaseException:
                            break
                expr._parse( instring, loc, doActions=False, callPreParse=False )
                skipText = instring[startLoc:loc]
                if self.includeMatch:
                    loc,mat = expr._parse(instring,loc,doActions,callPreParse=False)
                    if mat:
                        skipRes = ParseResults( skipText )
                        skipRes += mat
                        return loc, [ skipRes ]
                    else:
                        return loc, [ skipText ]
                else:
                    return loc, [ skipText ]
            except (ParseException,IndexError):
                if failParse:
                    raise
                else:
                    loc += 1
        raise ParseException(instring, loc, self.errmsg, self)

class Forward(ParseElementEnhance):
    """Forward declaration of an expression to be defined later -
       used for recursive grammars, such as algebraic infix notation.
       When the expression is known, it is assigned to the C{Forward} variable using the '<<' operator.

       Note: take care when assigning to C{Forward} not to overlook precedence of operators.
       Specifically, '|' has a lower precedence than '<<', so that::
          fwdExpr << a | b | c
       will actually be evaluated as::
          (fwdExpr << a) | b | c
       thereby leaving b and c out as parseable alternatives.  It is recommended that you
       explicitly group the values inserted into the C{Forward}::
          fwdExpr << (a | b | c)
       Converting to use the '<<=' operator instead will avoid this problem.
    """
    def __init__( self, other=None ):
        super(Forward,self).__init__( other, savelist=False )

    def __lshift__( self, other ):
        if isinstance( other, basestring ):
            other = ParserElement.literalStringClass(other)
        self.expr = other
        self.mayReturnEmpty = other.mayReturnEmpty
        self.strRepr = None
        self.mayIndexError = self.expr.mayIndexError
        self.mayReturnEmpty = self.expr.mayReturnEmpty
        self.setWhitespaceChars( self.expr.whiteChars )
        self.skipWhitespace = self.expr.skipWhitespace
        self.saveAsList = self.expr.saveAsList
        self.ignoreExprs.extend(self.expr.ignoreExprs)
        return self

    def __ilshift__(self, other):
        return self << other

    def leaveWhitespace( self ):
        self.skipWhitespace = False
        return self

    def streamline( self ):
        if not self.streamlined:
            self.streamlined = True
            if self.expr is not None:
                self.expr.streamline()
        return self

    def validate( self, validateTrace=[] ):
        if self not in validateTrace:
            tmp = validateTrace[:]+[self]
            if self.expr is not None:
                self.expr.validate(tmp)
        self.checkRecursion([])

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        self._revertClass = self.__class__
        self.__class__ = _ForwardNoRecurse
        try:
            if self.expr is not None:
                retString = _ustr(self.expr)
            else:
                retString = "None"
        finally:
            self.__class__ = self._revertClass
        return self.__class__.__name__ + ": " + retString

    def copy(self):
        if self.expr is not None:
            return super(Forward,self).copy()
        else:
            ret = Forward()
            ret <<= self
            return ret

class _ForwardNoRecurse(Forward):
    def __str__( self ):
        return "..."

class TokenConverter(ParseElementEnhance):
    """Abstract subclass of C{ParseExpression}, for converting parsed results."""
    def __init__( self, expr, savelist=False ):
        super(TokenConverter,self).__init__( expr )#, savelist )
        self.saveAsList = False

class Upcase(TokenConverter):
    """Converter to upper case all matching tokens."""
    def __init__(self, *args):
        super(Upcase,self).__init__(*args)
        warnings.warn("Upcase class is deprecated, use upcaseTokens parse action instead",
                       DeprecationWarning,stacklevel=2)

    def postParse( self, instring, loc, tokenlist ):
        return list(map( str.upper, tokenlist ))


class Combine(TokenConverter):
    """Converter to concatenate all matching tokens to a single string.
       By default, the matching patterns must also be contiguous in the input string;
       this can be disabled by specifying C{'adjacent=False'} in the constructor.
    """
    def __init__( self, expr, joinString="", adjacent=True ):
        super(Combine,self).__init__( expr )
        # suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself
        if adjacent:
            self.leaveWhitespace()
        self.adjacent = adjacent
        self.skipWhitespace = True
        self.joinString = joinString
        self.callPreparse = True

    def ignore( self, other ):
        if self.adjacent:
            ParserElement.ignore(self, other)
        else:
            super( Combine, self).ignore( other )
        return self

    def postParse( self, instring, loc, tokenlist ):
        retToks = tokenlist.copy()
        del retToks[:]
        retToks += ParseResults([ "".join(tokenlist._asStringList(self.joinString)) ], modal=self.modalResults)

        if self.resultsName and retToks.haskeys():
            return [ retToks ]
        else:
            return retToks

class Group(TokenConverter):
    """Converter to return the matched tokens as a list - useful for returning tokens of C{L{ZeroOrMore}} and C{L{OneOrMore}} expressions."""
    def __init__( self, expr ):
        super(Group,self).__init__( expr )
        self.saveAsList = True

    def postParse( self, instring, loc, tokenlist ):
        return [ tokenlist ]

class Dict(TokenConverter):
    """Converter to return a repetitive expression as a list, but also as a dictionary.
       Each element can also be referenced using the first token in the expression as its key.
       Useful for tabular report scraping when the first column can be used as a item key.
    """
    def __init__( self, expr ):
        super(Dict,self).__init__( expr )
        self.saveAsList = True

    def postParse( self, instring, loc, tokenlist ):
        for i,tok in enumerate(tokenlist):
            if len(tok) == 0:
                continue
            ikey = tok[0]
            if isinstance(ikey,int):
                ikey = _ustr(tok[0]).strip()
            if len(tok)==1:
                tokenlist[ikey] = _ParseResultsWithOffset("",i)
            elif len(tok)==2 and not isinstance(tok[1],ParseResults):
                tokenlist[ikey] = _ParseResultsWithOffset(tok[1],i)
            else:
                dictvalue = tok.copy() #ParseResults(i)
                del dictvalue[0]
                if len(dictvalue)!= 1 or (isinstance(dictvalue,ParseResults) and dictvalue.haskeys()):
                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue,i)
                else:
                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue[0],i)

        if self.resultsName:
            return [ tokenlist ]
        else:
            return tokenlist


class Suppress(TokenConverter):
    """Converter for ignoring the results of a parsed expression."""
    def postParse( self, instring, loc, tokenlist ):
        return []

    def suppress( self ):
        return self


class OnlyOnce(object):
    """Wrapper for parse actions, to ensure they are only called once."""
    def __init__(self, methodCall):
        self.callable = _trim_arity(methodCall)
        self.called = False
    def __call__(self,s,l,t):
        if not self.called:
            results = self.callable(s,l,t)
            self.called = True
            return results
        raise ParseException(s,l,"")
    def reset(self):
        self.called = False

def traceParseAction(f):
    """Decorator for debugging parse actions."""
    f = _trim_arity(f)
    def z(*paArgs):
        thisFunc = f.func_name
        s,l,t = paArgs[-3:]
        if len(paArgs)>3:
            thisFunc = paArgs[0].__class__.__name__ + '.' + thisFunc
        sys.stderr.write( ">>entering %s(line: '%s', %d, %s)\n" % (thisFunc,line(l,s),l,t) )
        try:
            ret = f(*paArgs)
        except Exception as exc:
            sys.stderr.write( "<<leaving %s (exception: %s)\n" % (thisFunc,exc) )
            raise
        sys.stderr.write( "<<leaving %s (ret: %s)\n" % (thisFunc,ret) )
        return ret
    try:
        z.__name__ = f.__name__
    except AttributeError:
        pass
    return z

#
# global helpers
#
def delimitedList( expr, delim=",", combine=False ):
    """Helper to define a delimited list of expressions - the delimiter defaults to ','.
       By default, the list elements and delimiters can have intervening whitespace, and
       comments, but this can be overridden by passing C{combine=True} in the constructor.
       If C{combine} is set to C{True}, the matching tokens are returned as a single token
       string, with the delimiters included; otherwise, the matching tokens are returned
       as a list of tokens, with the delimiters suppressed.
    """
    dlName = _ustr(expr)+" ["+_ustr(delim)+" "+_ustr(expr)+"]..."
    if combine:
        return Combine( expr + ZeroOrMore( delim + expr ) ).setName(dlName)
    else:
        return ( expr + ZeroOrMore( Suppress( delim ) + expr ) ).setName(dlName)

def countedArray( expr, intExpr=None ):
    """Helper to define a counted list of expressions.
       This helper defines a pattern of the form::
           integer expr expr expr...
       where the leading integer tells how many expr expressions follow.
       The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed.
    """
    arrayExpr = Forward()
    def countFieldParseAction(s,l,t):
        n = t[0]
        arrayExpr << (n and Group(And([expr]*n)) or Group(empty))
        return []
    if intExpr is None:
        intExpr = Word(nums).setParseAction(lambda t:int(t[0]))
    else:
        intExpr = intExpr.copy()
    intExpr.setName("arrayLen")
    intExpr.addParseAction(countFieldParseAction, callDuringTry=True)
    return ( intExpr + arrayExpr )

def _flatten(L):
    ret = []
    for i in L:
        if isinstance(i,list):
            ret.extend(_flatten(i))
        else:
            ret.append(i)
    return ret

def matchPreviousLiteral(expr):
    """Helper to define an expression that is indirectly defined from
       the tokens matched in a previous expression, that is, it looks
       for a 'repeat' of a previous expression.  For example::
           first = Word(nums)
           second = matchPreviousLiteral(first)
           matchExpr = first + ":" + second
       will match C{"1:1"}, but not C{"1:2"}.  Because this matches a
       previous literal, will also match the leading C{"1:1"} in C{"1:10"}.
       If this is not desired, use C{matchPreviousExpr}.
       Do *not* use with packrat parsing enabled.
    """
    rep = Forward()
    def copyTokenToRepeater(s,l,t):
        if t:
            if len(t) == 1:
                rep << t[0]
            else:
                # flatten t tokens
                tflat = _flatten(t.asList())
                rep << And( [ Literal(tt) for tt in tflat ] )
        else:
            rep << Empty()
    expr.addParseAction(copyTokenToRepeater, callDuringTry=True)
    return rep

def matchPreviousExpr(expr):
    """Helper to define an expression that is indirectly defined from
       the tokens matched in a previous expression, that is, it looks
       for a 'repeat' of a previous expression.  For example::
           first = Word(nums)
           second = matchPreviousExpr(first)
           matchExpr = first + ":" + second
       will match C{"1:1"}, but not C{"1:2"}.  Because this matches by
       expressions, will *not* match the leading C{"1:1"} in C{"1:10"};
       the expressions are evaluated first, and then compared, so
       C{"1"} is compared with C{"10"}.
       Do *not* use with packrat parsing enabled.
    """
    rep = Forward()
    e2 = expr.copy()
    rep <<= e2
    def copyTokenToRepeater(s,l,t):
        matchTokens = _flatten(t.asList())
        def mustMatchTheseTokens(s,l,t):
            theseTokens = _flatten(t.asList())
            if  theseTokens != matchTokens:
                raise ParseException("",0,"")
        rep.setParseAction( mustMatchTheseTokens, callDuringTry=True )
    expr.addParseAction(copyTokenToRepeater, callDuringTry=True)
    return rep

def _escapeRegexRangeChars(s):
    #~  escape these chars: ^-]
    for c in r"\^-]":
        s = s.replace(c,_bslash+c)
    s = s.replace("\n",r"\n")
    s = s.replace("\t",r"\t")
    return _ustr(s)

def oneOf( strs, caseless=False, useRegex=True ):
    """Helper to quickly define a set of alternative Literals, and makes sure to do
       longest-first testing when there is a conflict, regardless of the input order,
       but returns a C{L{MatchFirst}} for best performance.

       Parameters:
        - strs - a string of space-delimited literals, or a list of string literals
        - caseless - (default=False) - treat all literals as caseless
        - useRegex - (default=True) - as an optimization, will generate a Regex
          object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or
          if creating a C{Regex} raises an exception)
    """
    if caseless:
        isequal = ( lambda a,b: a.upper() == b.upper() )
        masks = ( lambda a,b: b.upper().startswith(a.upper()) )
        parseElementClass = CaselessLiteral
    else:
        isequal = ( lambda a,b: a == b )
        masks = ( lambda a,b: b.startswith(a) )
        parseElementClass = Literal

    symbols = []
    if isinstance(strs,basestring):
        symbols = strs.split()
    elif isinstance(strs, collections.Sequence):
        symbols = list(strs[:])
    elif isinstance(strs, _generatorType):
        symbols = list(strs)
    else:
        warnings.warn("Invalid argument to oneOf, expected string or list",
                SyntaxWarning, stacklevel=2)
    if not symbols:
        return NoMatch()

    i = 0
    while i < len(symbols)-1:
        cur = symbols[i]
        for j,other in enumerate(symbols[i+1:]):
            if ( isequal(other, cur) ):
                del symbols[i+j+1]
                break
            elif ( masks(cur, other) ):
                del symbols[i+j+1]
                symbols.insert(i,other)
                cur = other
                break
        else:
            i += 1

    if not caseless and useRegex:
        #~ print (strs,"->", "|".join( [ _escapeRegexChars(sym) for sym in symbols] ))
        try:
            if len(symbols)==len("".join(symbols)):
                return Regex( "[%s]" % "".join(_escapeRegexRangeChars(sym) for sym in symbols) )
            else:
                return Regex( "|".join(re.escape(sym) for sym in symbols) )
        except:
            warnings.warn("Exception creating Regex for oneOf, building MatchFirst",
                    SyntaxWarning, stacklevel=2)


    # last resort, just use MatchFirst
    return MatchFirst( [ parseElementClass(sym) for sym in symbols ] )

def dictOf( key, value ):
    """Helper to easily and clearly define a dictionary by specifying the respective patterns
       for the key and value.  Takes care of defining the C{L{Dict}}, C{L{ZeroOrMore}}, and C{L{Group}} tokens
       in the proper order.  The key pattern can include delimiting markers or punctuation,
       as long as they are suppressed, thereby leaving the significant key text.  The value
       pattern can include named results, so that the C{Dict} results can include named token
       fields.
    """
    return Dict( ZeroOrMore( Group ( key + value ) ) )

def originalTextFor(expr, asString=True):
    """Helper to return the original, untokenized text for a given expression.  Useful to
       restore the parsed fields of an HTML start tag into the raw tag text itself, or to
       revert separate tokens with intervening whitespace back to the original matching
       input text. Simpler to use than the parse action C{L{keepOriginalText}}, and does not
       require the inspect module to chase up the call stack.  By default, returns a
       string containing the original parsed text.

       If the optional C{asString} argument is passed as C{False}, then the return value is a
       C{L{ParseResults}} containing any results names that were originally matched, and a
       single token containing the original matched text from the input string.  So if
       the expression passed to C{L{originalTextFor}} contains expressions with defined
       results names, you must set C{asString} to C{False} if you want to preserve those
       results name values."""
    locMarker = Empty().setParseAction(lambda s,loc,t: loc)
    endlocMarker = locMarker.copy()
    endlocMarker.callPreparse = False
    matchExpr = locMarker("_original_start") + expr + endlocMarker("_original_end")
    if asString:
        extractText = lambda s,l,t: s[t._original_start:t._original_end]
    else:
        def extractText(s,l,t):
            del t[:]
            t.insert(0, s[t._original_start:t._original_end])
            del t["_original_start"]
            del t["_original_end"]
    matchExpr.setParseAction(extractText)
    return matchExpr

def ungroup(expr):
    """Helper to undo pyparsing's default grouping of And expressions, even
       if all but one are non-empty."""
    return TokenConverter(expr).setParseAction(lambda t:t[0])

def locatedExpr(expr):
    """Helper to decorate a returned token with its starting and ending locations in the input string.
       This helper adds the following results names:
        - locn_start = location where matched expression begins
        - locn_end = location where matched expression ends
        - value = the actual parsed results

       Be careful if the input text contains C{<TAB>} characters, you may want to call
       C{L{ParserElement.parseWithTabs}}
    """
    locator = Empty().setParseAction(lambda s,l,t: l)
    return Group(locator("locn_start") + expr("value") + locator.copy().leaveWhitespace()("locn_end"))


# convenience constants for positional expressions
empty       = Empty().setName("empty")
lineStart   = LineStart().setName("lineStart")
lineEnd     = LineEnd().setName("lineEnd")
stringStart = StringStart().setName("stringStart")
stringEnd   = StringEnd().setName("stringEnd")

_escapedPunc = Word( _bslash, r"\[]-*.$+^?()~ ", exact=2 ).setParseAction(lambda s,l,t:t[0][1])
_escapedHexChar = Regex(r"\\0?[xX][0-9a-fA-F]+").setParseAction(lambda s,l,t:unichr(int(t[0].lstrip(r'\0x'),16)))
_escapedOctChar = Regex(r"\\0[0-7]+").setParseAction(lambda s,l,t:unichr(int(t[0][1:],8)))
_singleChar = _escapedPunc | _escapedHexChar | _escapedOctChar | Word(printables, excludeChars=r'\]', exact=1)
_charRange = Group(_singleChar + Suppress("-") + _singleChar)
_reBracketExpr = Literal("[") + Optional("^").setResultsName("negate") + Group( OneOrMore( _charRange | _singleChar ) ).setResultsName("body") + "]"

def srange(s):
    r"""Helper to easily define string ranges for use in Word construction.  Borrows
       syntax from regexp '[]' string range definitions::
          srange("[0-9]")   -> "0123456789"
          srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"
          srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"
       The input string must be enclosed in []'s, and the returned string is the expanded
       character set joined into a single string.
       The values enclosed in the []'s may be::
          a single character
          an escaped character with a leading backslash (such as \- or \])
          an escaped hex character with a leading '\x' (\x21, which is a '!' character)
            (\0x## is also supported for backwards compatibility)
          an escaped octal character with a leading '\0' (\041, which is a '!' character)
          a range of any of the above, separated by a dash ('a-z', etc.)
          any combination of the above ('aeiouy', 'a-zA-Z0-9_$', etc.)
    """
    _expanded = lambda p: p if not isinstance(p,ParseResults) else ''.join(unichr(c) for c in range(ord(p[0]),ord(p[1])+1))
    try:
        return "".join(_expanded(part) for part in _reBracketExpr.parseString(s).body)
    except:
        return ""

def matchOnlyAtCol(n):
    """Helper method for defining parse actions that require matching at a specific
       column in the input text.
    """
    def verifyCol(strg,locn,toks):
        if col(locn,strg) != n:
            raise ParseException(strg,locn,"matched token not at column %d" % n)
    return verifyCol

def replaceWith(replStr):
    """Helper method for common parse actions that simply return a literal value.  Especially
       useful when used with C{L{transformString<ParserElement.transformString>}()}.
    """
    def _replFunc(*args):
        return [replStr]
    return _replFunc

def removeQuotes(s,l,t):
    """Helper parse action for removing quotation marks from parsed quoted strings.
       To use, add this parse action to quoted string using::
         quotedString.setParseAction( removeQuotes )
    """
    return t[0][1:-1]

def upcaseTokens(s,l,t):
    """Helper parse action to convert tokens to upper case."""
    return [ tt.upper() for tt in map(_ustr,t) ]

def downcaseTokens(s,l,t):
    """Helper parse action to convert tokens to lower case."""
    return [ tt.lower() for tt in map(_ustr,t) ]

def keepOriginalText(s,startLoc,t):
    """DEPRECATED - use new helper method C{L{originalTextFor}}.
       Helper parse action to preserve original parsed text,
       overriding any nested parse actions."""
    try:
        endloc = getTokensEndLoc()
    except ParseException:
        raise ParseFatalException("incorrect usage of keepOriginalText - may only be called as a parse action")
    del t[:]
    t += ParseResults(s[startLoc:endloc])
    return t

def getTokensEndLoc():
    """Method to be called from within a parse action to determine the end
       location of the parsed tokens."""
    import inspect
    fstack = inspect.stack()
    try:
        # search up the stack (through intervening argument normalizers) for correct calling routine
        for f in fstack[2:]:
            if f[3] == "_parseNoCache":
                endloc = f[0].f_locals["loc"]
                return endloc
        else:
            raise ParseFatalException("incorrect usage of getTokensEndLoc - may only be called from within a parse action")
    finally:
        del fstack

def _makeTags(tagStr, xml):
    """Internal helper to construct opening and closing tag expressions, given a tag name"""
    if isinstance(tagStr,basestring):
        resname = tagStr
        tagStr = Keyword(tagStr, caseless=not xml)
    else:
        resname = tagStr.name

    tagAttrName = Word(alphas,alphanums+"_-:")
    if (xml):
        tagAttrValue = dblQuotedString.copy().setParseAction( removeQuotes )
        openTag = Suppress("<") + tagStr("tag") + \
                Dict(ZeroOrMore(Group( tagAttrName + Suppress("=") + tagAttrValue ))) + \
                Optional("/",default=[False]).setResultsName("empty").setParseAction(lambda s,l,t:t[0]=='/') + Suppress(">")
    else:
        printablesLessRAbrack = "".join(c for c in printables if c not in ">")
        tagAttrValue = quotedString.copy().setParseAction( removeQuotes ) | Word(printablesLessRAbrack)
        openTag = Suppress("<") + tagStr("tag") + \
                Dict(ZeroOrMore(Group( tagAttrName.setParseAction(downcaseTokens) + \
                Optional( Suppress("=") + tagAttrValue ) ))) + \
                Optional("/",default=[False]).setResultsName("empty").setParseAction(lambda s,l,t:t[0]=='/') + Suppress(">")
    closeTag = Combine(_L("</") + tagStr + ">")

    openTag = openTag.setResultsName("start"+"".join(resname.replace(":"," ").title().split())).setName("<%s>" % tagStr)
    closeTag = closeTag.setResultsName("end"+"".join(resname.replace(":"," ").title().split())).setName("</%s>" % tagStr)
    openTag.tag = resname
    closeTag.tag = resname
    return openTag, closeTag

def makeHTMLTags(tagStr):
    """Helper to construct opening and closing tag expressions for HTML, given a tag name"""
    return _makeTags( tagStr, False )

def makeXMLTags(tagStr):
    """Helper to construct opening and closing tag expressions for XML, given a tag name"""
    return _makeTags( tagStr, True )

def withAttribute(*args,**attrDict):
    """Helper to create a validating parse action to be used with start tags created
       with C{L{makeXMLTags}} or C{L{makeHTMLTags}}. Use C{withAttribute} to qualify a starting tag
       with a required attribute value, to avoid false matches on common tags such as
       C{<TD>} or C{<DIV>}.

       Call C{withAttribute} with a series of attribute names and values. Specify the list
       of filter attributes names and values as:
        - keyword arguments, as in C{(align="right")}, or
        - as an explicit dict with C{**} operator, when an attribute name is also a Python
          reserved word, as in C{**{"class":"Customer", "align":"right"}}
        - a list of name-value tuples, as in ( ("ns1:class", "Customer"), ("ns2:align","right") )
       For attribute names with a namespace prefix, you must use the second form.  Attribute
       names are matched insensitive to upper/lower case.

       To verify that the attribute exists, but without specifying a value, pass
       C{withAttribute.ANY_VALUE} as the value.
       """
    if args:
        attrs = args[:]
    else:
        attrs = attrDict.items()
    attrs = [(k,v) for k,v in attrs]
    def pa(s,l,tokens):
        for attrName,attrValue in attrs:
            if attrName not in tokens:
                raise ParseException(s,l,"no matching attribute " + attrName)
            if attrValue != withAttribute.ANY_VALUE and tokens[attrName] != attrValue:
                raise ParseException(s,l,"attribute '%s' has value '%s', must be '%s'" %
                                            (attrName, tokens[attrName], attrValue))
    return pa
withAttribute.ANY_VALUE = object()

opAssoc = _Constants()
opAssoc.LEFT = object()
opAssoc.RIGHT = object()

def infixNotation( baseExpr, opList, lpar=Suppress('('), rpar=Suppress(')') ):
    """Helper method for constructing grammars of expressions made up of
       operators working in a precedence hierarchy.  Operators may be unary or
       binary, left- or right-associative.  Parse actions can also be attached
       to operator expressions.

       Parameters:
        - baseExpr - expression representing the most basic element for the nested
        - opList - list of tuples, one for each operator precedence level in the
          expression grammar; each tuple is of the form
          (opExpr, numTerms, rightLeftAssoc, parseAction), where:
           - opExpr is the pyparsing expression for the operator;
              may also be a string, which will be converted to a Literal;
              if numTerms is 3, opExpr is a tuple of two expressions, for the
              two operators separating the 3 terms
           - numTerms is the number of terms for this operator (must
              be 1, 2, or 3)
           - rightLeftAssoc is the indicator whether the operator is
              right or left associative, using the pyparsing-defined
              constants C{opAssoc.RIGHT} and C{opAssoc.LEFT}.
           - parseAction is the parse action to be associated with
              expressions matching this operator expression (the
              parse action tuple member may be omitted)
        - lpar - expression for matching left-parentheses (default=Suppress('('))
        - rpar - expression for matching right-parentheses (default=Suppress(')'))
    """
    ret = Forward()
    lastExpr = baseExpr | ( lpar + ret + rpar )
    for i,operDef in enumerate(opList):
        opExpr,arity,rightLeftAssoc,pa = (operDef + (None,))[:4]
        if arity == 3:
            if opExpr is None or len(opExpr) != 2:
                raise ValueError("if numterms=3, opExpr must be a tuple or list of two expressions")
            opExpr1, opExpr2 = opExpr
        thisExpr = Forward()#.setName("expr%d" % i)
        if rightLeftAssoc == opAssoc.LEFT:
            if arity == 1:
                matchExpr = FollowedBy(lastExpr + opExpr) + Group( lastExpr + OneOrMore( opExpr ) )
            elif arity == 2:
                if opExpr is not None:
                    matchExpr = FollowedBy(lastExpr + opExpr + lastExpr) + Group( lastExpr + OneOrMore( opExpr + lastExpr ) )
                else:
                    matchExpr = FollowedBy(lastExpr+lastExpr) + Group( lastExpr + OneOrMore(lastExpr) )
            elif arity == 3:
                matchExpr = FollowedBy(lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr) + \
                            Group( lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr )
            else:
                raise ValueError("operator must be unary (1), binary (2), or ternary (3)")
        elif rightLeftAssoc == opAssoc.RIGHT:
            if arity == 1:
                # try to avoid LR with this extra test
                if not isinstance(opExpr, Optional):
                    opExpr = Optional(opExpr)
                matchExpr = FollowedBy(opExpr.expr + thisExpr) + Group( opExpr + thisExpr )
            elif arity == 2:
                if opExpr is not None:
                    matchExpr = FollowedBy(lastExpr + opExpr + thisExpr) + Group( lastExpr + OneOrMore( opExpr + thisExpr ) )
                else:
                    matchExpr = FollowedBy(lastExpr + thisExpr) + Group( lastExpr + OneOrMore( thisExpr ) )
            elif arity == 3:
                matchExpr = FollowedBy(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr) + \
                            Group( lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr )
            else:
                raise ValueError("operator must be unary (1), binary (2), or ternary (3)")
        else:
            raise ValueError("operator must indicate right or left associativity")
        if pa:
            matchExpr.setParseAction( pa )
        thisExpr <<= ( matchExpr | lastExpr )
        lastExpr = thisExpr
    ret <<= lastExpr
    return ret
operatorPrecedence = infixNotation

dblQuotedString = Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\x[0-9a-fA-F]+)|(?:\\.))*"').setName("string enclosed in double quotes")
sglQuotedString = Regex(r"'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA-F]+)|(?:\\.))*'").setName("string enclosed in single quotes")
quotedString = Regex(r'''(?:"(?:[^"\n\r\\]|(?:"")|(?:\\x[0-9a-fA-F]+)|(?:\\.))*")|(?:'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA-F]+)|(?:\\.))*')''').setName("quotedString using single or double quotes")
unicodeString = Combine(_L('u') + quotedString.copy())

def nestedExpr(opener="(", closer=")", content=None, ignoreExpr=quotedString.copy()):
    """Helper method for defining nested lists enclosed in opening and closing
       delimiters ("(" and ")" are the default).

       Parameters:
        - opener - opening character for a nested list (default="("); can also be a pyparsing expression
        - closer - closing character for a nested list (default=")"); can also be a pyparsing expression
        - content - expression for items within the nested lists (default=None)
        - ignoreExpr - expression for ignoring opening and closing delimiters (default=quotedString)

       If an expression is not provided for the content argument, the nested
       expression will capture all whitespace-delimited content between delimiters
       as a list of separate values.

       Use the C{ignoreExpr} argument to define expressions that may contain
       opening or closing characters that should not be treated as opening
       or closing characters for nesting, such as quotedString or a comment
       expression.  Specify multiple expressions using an C{L{Or}} or C{L{MatchFirst}}.
       The default is L{quotedString}, but if no expressions are to be ignored,
       then pass C{None} for this argument.
    """
    if opener == closer:
        raise ValueError("opening and closing strings cannot be the same")
    if content is None:
        if isinstance(opener,basestring) and isinstance(closer,basestring):
            if len(opener) == 1 and len(closer)==1:
                if ignoreExpr is not None:
                    content = (Combine(OneOrMore(~ignoreExpr +
                                    CharsNotIn(opener+closer+ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
                else:
                    content = (empty.copy()+CharsNotIn(opener+closer+ParserElement.DEFAULT_WHITE_CHARS
                                ).setParseAction(lambda t:t[0].strip()))
            else:
                if ignoreExpr is not None:
                    content = (Combine(OneOrMore(~ignoreExpr +
                                    ~Literal(opener) + ~Literal(closer) +
                                    CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
                else:
                    content = (Combine(OneOrMore(~Literal(opener) + ~Literal(closer) +
                                    CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
        else:
            raise ValueError("opening and closing arguments must be strings if no content expression is given")
    ret = Forward()
    if ignoreExpr is not None:
        ret <<= Group( Suppress(opener) + ZeroOrMore( ignoreExpr | ret | content ) + Suppress(closer) )
    else:
        ret <<= Group( Suppress(opener) + ZeroOrMore( ret | content )  + Suppress(closer) )
    return ret

def indentedBlock(blockStatementExpr, indentStack, indent=True):
    """Helper method for defining space-delimited indentation blocks, such as
       those used to define block statements in Python source code.

       Parameters:
        - blockStatementExpr - expression defining syntax of statement that
            is repeated within the indented block
        - indentStack - list created by caller to manage indentation stack
            (multiple statementWithIndentedBlock expressions within a single grammar
            should share a common indentStack)
        - indent - boolean indicating whether block must be indented beyond the
            the current level; set to False for block of left-most statements
            (default=True)

       A valid block must contain at least one C{blockStatement}.
    """
    def checkPeerIndent(s,l,t):
        if l >= len(s): return
        curCol = col(l,s)
        if curCol != indentStack[-1]:
            if curCol > indentStack[-1]:
                raise ParseFatalException(s,l,"illegal nesting")
            raise ParseException(s,l,"not a peer entry")

    def checkSubIndent(s,l,t):
        curCol = col(l,s)
        if curCol > indentStack[-1]:
            indentStack.append( curCol )
        else:
            raise ParseException(s,l,"not a subentry")

    def checkUnindent(s,l,t):
        if l >= len(s): return
        curCol = col(l,s)
        if not(indentStack and curCol < indentStack[-1] and curCol <= indentStack[-2]):
            raise ParseException(s,l,"not an unindent")
        indentStack.pop()

    NL = OneOrMore(LineEnd().setWhitespaceChars("\t ").suppress())
    INDENT = Empty() + Empty().setParseAction(checkSubIndent)
    PEER   = Empty().setParseAction(checkPeerIndent)
    UNDENT = Empty().setParseAction(checkUnindent)
    if indent:
        smExpr = Group( Optional(NL) +
            #~ FollowedBy(blockStatementExpr) +
            INDENT + (OneOrMore( PEER + Group(blockStatementExpr) + Optional(NL) )) + UNDENT)
    else:
        smExpr = Group( Optional(NL) +
            (OneOrMore( PEER + Group(blockStatementExpr) + Optional(NL) )) )
    blockStatementExpr.ignore(_bslash + LineEnd())
    return smExpr

alphas8bit = srange(r"[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]")
punc8bit = srange(r"[\0xa1-\0xbf\0xd7\0xf7]")

anyOpenTag,anyCloseTag = makeHTMLTags(Word(alphas,alphanums+"_:"))
commonHTMLEntity = Combine(_L("&") + oneOf("gt lt amp nbsp quot").setResultsName("entity") +";").streamline()
_htmlEntityMap = dict(zip("gt lt amp nbsp quot".split(),'><& "'))
replaceHTMLEntity = lambda t : t.entity in _htmlEntityMap and _htmlEntityMap[t.entity] or None

# it's easy to get these comment structures wrong - they're very common, so may as well make them available
cStyleComment = Regex(r"/\*(?:[^*]*\*+)+?/").setName("C style comment")

htmlComment = Regex(r"<!--[\s\S]*?-->")
restOfLine = Regex(r".*").leaveWhitespace()
dblSlashComment = Regex(r"\/\/(\\\n|.)*").setName("// comment")
cppStyleComment = Regex(r"/(?:\*(?:[^*]*\*+)+?/|/[^\n]*(?:\n[^\n]*)*?(?:(?<!\\)|\Z))").setName("C++ style comment")

javaStyleComment = cppStyleComment
pythonStyleComment = Regex(r"#.*").setName("Python style comment")
_commasepitem = Combine(OneOrMore(Word(printables, excludeChars=',') +
                                  Optional( Word(" \t") +
                                            ~Literal(",") + ~LineEnd() ) ) ).streamline().setName("commaItem")
commaSeparatedList = delimitedList( Optional( quotedString.copy() | _commasepitem, default="") ).setName("commaSeparatedList")

####################################################################################################
######################### ButterFly #########################################################
####################################################################################################

import glob
import os, os.path
import argparse
import datetime
import re
import shutil
import difflib
import pdb

####################################################################################################
######################### Helper Functions #########################################################
####################################################################################################
_TAB = '    '

def curTimeStr():
    return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

class DotDict(dict):
    def __getattr__(self, key):
        return self.__getitem__(key)

def genJavaComment():
    return '''/**

                                MMMMM
                                  MMMMMM
                                    MMMMMMM
                                     MMMMMMMM     .
                                      MMMMMMMMM
                                      HMMMMMMMMMM
                                       MMMMMMMMMMMM  M
                                       MMMMMMMMMMMMM  M
                                        MMMMMMMMMMMMM  M
                                        MMMMMMMMMMMMM:
                                        oMMMMMMMMMMMMMM
              .MMMMMMMMMMMMMMo           MMMMMMMMMMMMMMM M
        MMMMMMMMMMMMMMMMMMMMMMMMMMM      MMMMMMMMMMMMMMMM
          MMMMMMMMMMMMMMMMMMMMMMMMMMMM.  oMMMMMMMMMMMMMMM.M
            MMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMMMMMMMMMMM
              MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                oMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:                     H
                     MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM                  .         MMM
                      MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM              M       MMMMMM
                       .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM          M   MMMMMMMMMM
                MM.      MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM       M MMMMMMMMMMMM
                    MM    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    .MMMMMMMMMMMMMM
                      MM  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                        MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
               .MMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                  HMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                     MMMMMMMMMMMMMMM MMM.oMMMMMMM..MMMMMMMMM:MMMMMMMMMMMMMMMMMMMMMMM
                       MMMMMMMMMMMMMM MM..MMMMMMM...MMMMMMM. MMMMMMMMMMMMMMMMMMMMM
                         MMMMMMMMMMMMMMM ..MMMMMM...MMMMMM ..MMMMMMMMMMMMMMMMMMM
                          MMMMMMM:M.MMM.M.. MMMMM M..MMMMM...MMMMMMMMMMMMMMMMMM  MMM
                            MMMM. .M..MM.M...MMMMMM..MMMMM.. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .
                             MMMM..M....M.....:MMM .MMMMMM..MMMMMMM...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                              MMM.M.. ...M......MM.MMMMM.......MHM.M  .MMMMMMMMMMMMMMMMMMMMMMMMM
                         MMMMMMMM..MM. . MMM.....MMMMMM.M.....M ..MM..M MMMMMMMMMMMMMMMMMMM
                            .MMMMMHMM. ..MMMM. MMM............o..... . .MMMMMMMMMMMMMMM
                               MMM. M... .........................M..:.MMMMMMMMMMMM
                                 oMMM............ .................M.M.MMMMMMMMM
                                    .....MM........................ . MMMMMM
                                   M.....M.....................o.MM.MMMMMMMM.
                                    M........................M.. ...MMMMMMMMMMMMMo
                                      :....MMM..............MMM..oMMMMMMM
                                       M...MMM.............MMMMMMM
                                          .............:MMMMMMMM
                                          M..... MMM.....M
                                          M M.............                                            AUTO GENERATED, DO NOT MODIFY!
                                          ................M
                                       ooM.................MM  MoMMMMMoooM
                                  MMoooM......................MoooooooH..oMM
                              MHooooMoM.....................MMooooooM........M
                            oooooooMoooM......... o........MoooooooM............
                            Mooooooooooo.......M.........Moooooooo:..............M
                           MooMoooooooooM...M........:Mooooooooooo:..............M
                          M..oooooooooooo .........Mooooooooooooooo..............M
                         M...Mooo:oooooooo.M....ooooooooooooooooooo..M...........M
                          ...oooooMoooooooM..Mooooooooooooo:oooooooM.M...........M.
                         M...ooooooMoo:ooooMoooooooooooooHoooooooooH:M. ...........:
                         M..MoooooooMoooooooooooooooooo:ooooooMooooMoM..............M
                         M..ooooooooooMooooooooooooooHoooooooMooHooooM...............M
                         ...ooooooooooooooooooo:MooooooooooooooMoMoooM................
                        M...oooooooooooooooooooooooooooooooooooooMooMM................M
                        ...MooooooooooooooooooooooooooooooooooooooooMo ................
                        ...MooooooooooooooooooooooooooooooooooooooooM M................M
                       M...ooooooooooooooooooooooooooooooooooooooooM   ................M
                       ...MoooooooooooooooooooooooooooooooooooooooMM   .:...............
                       .....MooooooooooooooooooooooooooooooooooooMoo       .............M
                       M...... ooooooooooooooooooooooooooooooooooooM       M..............M
                       M........MooooMMM MM MM  MMMMMMMMMooooooooM         M...............M
                       .........HM     M:  MM :MMMMMM          M           M...............
                      M..........M     M   MoM M                           M................M
                      M.........:M  MoH  M M M MooooHoooMM.   M             M...............M
                      M..........Moooo MMooM    oooooMooooooooM              M..............H
                      M.........MooooM  Mooo  : ooooooMooooMoooM              M........ . .o.M
                      H..  .....ooooo   oooo  M MooooooooooooooM               M... MMMMMMMMMMM
                      MMMMMMMMMMooooM M oooo  .  ooooooMooooooooM              .MMMMMMMMMMMMMMM
                      MMMMMMMMMMooooH : ooooH    oooooooooooooooo               MMMMMMMMMMMMMMM
                      MMMMMMMMMMoooo    ooooM    Moooooooooooooooo              .MMMMMMMMMMMMMMM
                      MMMMMMMMMMoooo    ooooM    MooooooooooooooooM              MMMMMMMMMMMMMMM
                      MMMMMMMMMMoooM    ooooM     ooooooooooooooooo               MMMMMMMMMMM:M
                      MMMMMMMMMMoooM   MooooM     oooooooooooMoooooo               MH...........
                       . ......Mooo.   MooooM     oooooooooooooooooo              M............M
                      M.M......oooo    MooooM     Moooooooooooooooooo:           .........M.....
                      M.M.....Moooo    MooooM      ooooooooooooooooooM            .M............
                      .......MooooH    MooooM      oooooooooMoooooooooo          M..o...M..o....M
                      .o....HMooooM    MooooH      MooooooooMooooooooooM          .:M...M.......M
                     M..M.....MoooM    :oooo:    .MooooooooHooMoooooooooM         M M... ..oM.M
                      M...M.:.Mooo. MMMMooooo   oooooooooooMoooooooooooooM          ....M. M
                       M:M..o.Moooooooooooooo MooooooooooooooMooooooooooooM          .Mo
                              MooooooooooooooMooooooooooooMoMoooooooooooooo
                              Mooooooooooooooo:ooooooooooooooooooooooooooooo
                              ooooooooooooooooMooooooooooMoooooooooooooooooo
                              ooooooooooooooooMoooooooooooMooooooooooooooooHo
                              ooMooooooooooooooMoooooooooooooooooooooooooooMoM
                             MooMoooooooooooooo.ooooooooooooooooooooooooooo:oM
                             MoooooooooooooooooooooooooooooooooooooooooooooooM
                             MoooMooooooooooooooMooooooooooooooooooooooooooooo.
                             MoooMooooooooooooooMoooooooooooooooooooooooooMooooM
                             MooooooooooooooooooMoooooooooooooooooooooooooMoooooM
                             MooooMoooooooooooooMoooooooooooooooooooooooooMoHooooM
                             ooooooMooooooooooooooooooooooooooooooooooooooooMoMoooM
                            MooooooooooooooooooooMooooooooooooooooooooooooooMoooooH:
                            MoooooooMooooooooooooMoooooooooooooooooooooooooooooHoooM
                            MooooooooMoooooooooooMoooooooooooooooooooooooooMoooMooooM
                            Moooooooooooooooooooooooooooooooooooooooooooooo.oooMooooo
                            MoooooooooooooooooooooooooooooooooooooooooooooMoooooooooM
                             MooooooooooooooooooooMoooooooooooooooooooooooooooooooooM
                              MooooooooooooooooooooMHooooooooooooooooooooMoooo:ooooo
                               MMooooooooooooooooooMoMHoooooooooooooooooooooooMooooo
                                MMoooooooooooooooMMooo MMooooooooooooooooooooooooooM
                                MMMoooooooooooooMooooo  oooooooooooooooooooooMooooo
                                MooMMoooooooooMoooMMoM  ooooHooooooooooooooooMooooM
                                MooooMooooooMooooMoooM  MoooooMoooooooooooooMooooo
                                ooooooMMooooooooMooooM  MoooooooooMooooooooooooooM
                                HooooooMoooooooMooooM    HoooooooHooMooooooooooooo
                                 oooMoooooooooHoooM         MoooooooooMoooooooooM
                                  HooooooooooooHM             MooooooooMMoooooooM
                                   MMMMMMMMMMMMMM                Moooooo:MooooHMM
                                    MMMMMMM: ...                  MMMMMMMMMMMMMM
                                   M............M                  MMMMMMMMM ....
                                   M.MM..........                  M.............M
                                M ..............MM                 M..............
                             MMMMM............MMMM                 ..MMMMMMMM ....M
                           MMMMMMMMMMMMMMMMMMMMMMMM               MMMMMMMMMMMMM...M
                        .MMMMMMMMMMMMMMMMMMMMMMMMMM               MMMMMMMMMMMMMMMMMM
                        MMMMMMMMMMMMMMMMMMMMMMMMM                MMMMMMMMMMMMMMMMMMM
                        :MMMMMMMMMMMMMMMMMMH                     MMMMMMMMMMMMMMMMMMM
                                                                 MMMMMMMMMMMMMMMMMM
                                                                 MMMMMMMMMMMMMMM
                                                                  HMMMMMM



*/'''

def isStr(s):
    return isinstance(s, str) or isinstance(s, unicode) or isinstance(s, basestring)

def isNum(s):
    return isinstance(s, int) or isinstance(s, long)

def isAnnotationedBy(obj, name):
    if getattr(obj, 'annotations', None) is None:
        return False
    for a in obj.annotations:
        if a.name == name:
            return True
    return False

def packageToJavaInterfaceName(packageName):
    parts = packageName.split('.')
    parts.append('Service')
    parts = parts[-2:]
    return ''.join([p.capitalize() for p in parts])

class MsgBuf(object):

    def __init__(self, tab=0):
        self.buf = []
        self.tab = tab

    def append(self, msg, indent=0):
        if msg is not None:
            self.buf.append((msg, indent))
        return self

    def appendEmptyLine(self):
        self.buf.append('\n')

    def prepend(self, msg, indent=0):
        if msg is not None:
            self.buf.insert(0, (msg, indent))
        return self

    def prependEmptyLine(self):
        self.buf.insert(0, '\n')

    def output(self, tab=0):
        return self._realOutput(self, tab)

    def _realOutput(self, buf, tab):
        rbuf = []
        for b in buf.buf:
            if isStr(b):
                rbuf.append(b)
            else:
                msg, indent = b
                if isStr(msg):
                    rbuf.append('%s%s' % (_TAB * tab, msg))
                else:
                    rbuf.append(self._realOutput(msg, indent + tab))
        return ''.join(rbuf)

####################################################################################################
######################### Parser ###################################################################
####################################################################################################

def parseObjFromFile(file):
    intNumber = Word(nums)
    number = Word(nums + ".-")
    string = quotedString
    identifier = Word(alphas, alphanums + "_")
    generic=Word(alphas)

    assignValue = (number | string)

    serviceIdentifier = CaselessKeyword("service")
    modelIndentifer = CaselessKeyword("model")
    enumIndentifer = CaselessKeyword('enum')

    paramType = Word(alphas + "<" + ">" + ",")
    paramName = identifier
    param = Group(paramType.setResultsName("paramType") + paramName.setResultsName("paramName")).setParseAction(lambda i: Param(i[0]))

    annotationValue = Group(Optional(identifier.setResultsName("key") + "=") + assignValue.setResultsName("value")).setParseAction(lambda i: AnnotationParam(i[0]))

    annotationExpr = Group("@" + identifier.setResultsName("name") + Optional("(" + Group(delimitedList(annotationValue)).setResultsName("params") + ")")).setParseAction(lambda i: Annotation(i[0]))

    serviceFuncExpr = Group(ZeroOrMore(javaStyleComment).setResultsName("comment")+ZeroOrMore(annotationExpr).setResultsName("annotations") + paramType.setResultsName("returnType") + identifier.setResultsName("name") + "(" + Optional(delimitedList(param)).setResultsName("params") + ")" + ";").setParseAction(lambda i: Func(i[0]))

    serviceExpr = Group(ZeroOrMore(javaStyleComment).setResultsName("comment")+ZeroOrMore(annotationExpr).setResultsName("annotations") + serviceIdentifier + identifier.setResultsName("name") + "{" + OneOrMore(serviceFuncExpr).setResultsName("funcs") + "}").setParseAction(lambda i: Service(i[0]))

    # serviceExpr.ignore(javaStyleComment)

    propertyExpr = Group(paramType.setResultsName("paramType") + paramName.setResultsName("paramName") + ";"+ZeroOrMore(javaStyleComment).setResultsName("comment")).setParseAction(lambda i: Param(i[0]))

    modelNameExpr=Group(identifier.setResultsName("name")+ZeroOrMore("<"+Group(delimitedList(generic)).setResultsName("generic")+">")).setParseAction(lambda i:ModelName(i[0]))

    modelExpr = Group(ZeroOrMore(javaStyleComment).setResultsName("comment")+ZeroOrMore(annotationExpr).setResultsName("annotations") + modelIndentifer + modelNameExpr.setResultsName("name") + "{" + OneOrMore(propertyExpr).setResultsName("properties") + "}").setParseAction(lambda i: Model(i[0]))

    enumPropertyExpr = Group(identifier.setResultsName("name") + "(" + delimitedList(assignValue).setResultsName("args") + ")" + ";").setParseAction(lambda i: EnumProperty(i[0]))
    enumExpr = Group(ZeroOrMore(javaStyleComment).setResultsName("comment")+ZeroOrMore(annotationExpr).setResultsName("annotations") + enumIndentifer + identifier.setResultsName("name") + "{" + OneOrMore(enumPropertyExpr).setResultsName("properties") + "}").setParseAction(lambda i: Enum(i[0]))

    codeBlock = OneOrMore((enumExpr | modelExpr | serviceExpr)).setResultsName("elements").setParseAction(lambda i: CodeBlock(i))


    contentParts = []
    if isinstance(file,list):
      for f in file:
        with open(f) as fp:
            contentParts.append(''.join(fp.readlines()))
    else:
      with open(file) as fp:
          contentParts.append(''.join(fp.readlines()))

    content = '\n'.join(contentParts)
    # import pdb;pdb.set_trace()
    # t1=codeBlock.scanString(content)
    # t2=codeBlock.transformString(content)
    # t3=codeBlock.parseString(content)
    try:
      ele=codeBlock.parseString(content,parseAll=True)[0]
    except ParseBaseException as exc:
      print 'error parse file <%s>' % file
      print 'error:%s' % exc
      exit(0)
    return ele

####################################################################################################
######################### Element Class ############################################################
####################################################################################################

class CodeBlock(object):
    def __init__(self, result):
        self.elements = result.elements

class EnumProperty(object):
    def __init__(self, result):
        self.name = result.name
        self.args = result.args or []

        if len(self.args) == 0 or len(self.args) > 2:
            raise Exception("number of properties is wrong %s" % len(self.args))
        if len(self.args) == 1:
            if not isNum(int(self.args[0])):
                raise Exception("no code in enum")
            self.code = self.args[0]
            self.desc = None
        else:
            self.code = self.args[0]
            self.desc = self.args[1]

class Enum(object):
    def __init__(self, result):
        self.annotations = result.annotations or []
        self.name = result.name
        self.properties = result.properties or []
        self.comment = result.comment or []

        self._ensure_equal_number_of_property()

    def _ensure_equal_number_of_property(self):
        if len(self.properties) == 0:
            raise Exception()
        l = len(self.properties[0].args)
        for p in self.properties:
            if l != len(p.args):
                raise Exception()

    def getComment(self):
        return "\n".join(self.comment)

class Model(object):
    def __init__(self, result):
        self.annotations = result.annotations or []
        self.name = result.name
        self.properties = result.properties
        self.comment = result.comment or []

    def getComment(self):
        return "\n".join(self.comment)

class Service(object):
    def __init__(self, result):
        self.annotations = result.annotations or []
        self.name = result.name
        self.funcs = result.funcs
        self.comment = result.comment or []

    def getUri(self):
        for a in self.annotations:
            if a.isUri():
                return a
        return None

    def getComment(self):
        return "\n".join(self.comment)

class AnnotationParam(object):
    def __init__(self, result):
        if result.key:
            self.key = result.key
        else:
            self.key = None
        self.value = result.value

    def valueOnly(self):
        return self.key is None

class Annotation(object):
    def __init__(self, result):
        self.name = result.name
        self.params = result.params or []

    def isUri(self):
        return self.name == 'uri' or self.name == 'turi'

    def getPrefix(self):
        if self.isUri():
          for p in self.params:
            if p.key == "prefix":
                return p.value.strip('"')
        return None

    def getServicePath(self):
        if self.getPrefix() is not None:
            for p in self.params:
                if p.key == "value":
                    return p.value.strip('"')
        else:
            return self.params[0].value.strip('"')



class ModelName(object):
    def __init__(self,result):
        self.name=result.name
        self.generic=result.generic or []

    def getGenericName(self):
        if self.generic:
          return "<%s>" % ",".join(self.generic)
        else:
          return ""

class Func(object):
    def __init__(self, result):
        #if result.name == 'getTestStr':
        # import pdb; pdb.set_trace()
        self.name = result.name
        self.returnType = result.returnType
        self.params = result.params or []
        self.annotations = result.annotations or []
        self.comment = result.comment or []
        self._ensure_uri()

    def _ensure_uri(self):
        #uriuri
        if self.getUri() is not None:
            self.getUri().name='turi'
            return
        urlParam = AnnotationParam(DotDict({'key': '', 'value': self.name}))
        uri = Annotation(DotDict({'name':'uri', 'params': [urlParam]}))
        self.annotations.append(uri)

    def isAnnotationed(self):
        return len(self.annotations) > 0

    def getUri(self):
        for a in self.annotations:
            if a.isUri():
                return a
        return None

    def returnList(self):
        return self.returnType.startswith("List<") or self.returnType.find("List<") >0

    def returnMap(self):
        return self.returnType.startswith("Map<") or self.returnType.find("Map<") >0

    def returnMapList(self):
        return  self.returnType.startswith("Map<") >0 and self.returnType.find("List<") >0

    def returnListMap(self):
        return  self.returnType.startswith("List<") >0 and self.returnType.find("Map<") >0

    def getRelParam(self):
        if self.returnMapList() or self.returnListMap():
            p=re.compile('([0-9a-zA-Z]*)(<*)Map<([0-9a-zA-Z]*),List<([0-9a-zA-Z]*)>>(>*)')
            m=p.match(self.returnType)
            if m is not None:
                return m.groups()
        elif self.returnList():
            p=re.compile('([0-9a-zA-Z]*)(<*)List<([0-9a-zA-Z]*)>(>*)')
            m=p.match(self.returnType)
            if m is not None:
                return m.groups()
        elif self.returnMap():
            p=re.compile('([0-9a-zA-Z]*)(<*)Map<([0-9a-zA-Z]*),([0-9a-zA-Z]*)>(>*)')
            m=p.match(self.returnType)
            if m is not None:
                return m.groups()
        else:
            p=re.compile('([0-9a-zA-Z]*)(<*)([0-9a-zA-Z]*)(>*)')
            m=p.match(self.returnType)
            if m is not None:
                return m.groups()

        return self.returnType

    def getAnnotation(self, name):
        for a in self.annotations:
            if a.name == name:
                return a
        return None

    def getComment(self):
        return "\n".join(self.comment)

class Param(object):
    def __init__(self, result):
        self.comment = result.comment
        self.paramType = result.paramType
        if self.paramType == 'ObjectId':
            self.paramType="String"
        self.paramName = result.paramName

    def isList(self):
        return self.paramType.startswith("List") or self.paramType.find("List") >0

    def isMap(self):
        return self.paramType.startswith("Map") or self.paramType.find("Map<") >0

    def isMapList(self):
        return self.paramType.find("List") >-1 and self.paramType.find("Map<") >-1

    def getRelParam(self):
        if self.isMapList():
            p=re.compile('Map<([0-9a-zA-Z]*),List<([0-9a-zA-Z]*)>>')
            m=p.match(self.paramType)
            if m is not None:
                return m.group(1),m.group(2)
        elif self.isList():
           # p=re.compile('List<([0-9a-zA-Z]*)>')
           # m=p.match(self.paramType)
           # if not m:
           #     import pdb;pdb.set_trace()
           # return m.group(1)
           return self.paramType.replace('List<','').replace('>','').split('<')
        elif self.isMap():
            p=re.compile('Map<([0-9a-zA-Z]*),([0-9a-zA-Z]*)>')
            m=p.match(self.paramType)
            return m.group(1),m.group(2)

        return self.paramType

    # def parseList(self):
    #     if self.isList():
    #         for p in self.getRelParam():
    #             if p not in ['<','>','list','map']:
    #                 return p

    def getComment(self):
        return "\n".join(self.comment)

####################################################################################################
######################### Writer ###################################################################
####################################################################################################

class BaseWriter(object):
    def __init__(self):
        self.imports = set()
        self.init()

class SpringMVCWriter(BaseWriter):

    def init(self):
        self.imports.add('org.springframework.web.bind.annotation.RequestMapping')

    def processNotModifyComment(self):
        return genJavaComment()

    def processAnnotationParam(self, value):
        if value.valueOnly():
            return value.value
        else:
            return '%s = %s' % (value.key, value.value)

    def processAnnotation(self, annotation):
        buf = MsgBuf()
        buf.append('@%s(' % annotation.name)
        for param in annotation.params:
            buf.append(self.processAnnotationParam(param))
        buf.append(')')
        buf.appendEmptyLine()
        return buf

    def processFuncUri(self, service, func, annotation):
        modelPath=annotation.params[0].value
        version = func.getAnnotation('version')
        target_uri = func.getAnnotation('turi')

        if target_uri is None:
            serviceUri = service.getUri()
            prefix=serviceUri.getPrefix()
            servicePath=serviceUri.getServicePath()
            if prefix is not None:
                if not version:
                    url= '%s/%s/%s' % (prefix,servicePath,modelPath)
                else:
                    url= '%s/%s/%s/v%s' % (prefix,servicePath,modelPath,version.params[0].value.strip('"'))
            else:
                if serviceUri is not None:
                    url = '%s/%s' % (servicePath, modelPath)
                if not version:
                    url = 'v%s/%s' % ('1', url)
                if version:
                    url = 'v%s/%s' % (version.params[0].value.strip('"'), url)
        else:
            url=target_uri.params[0].value.strip('"')
        self.imports.add('org.springframework.web.bind.annotation.RequestMethod')
        return '@RequestMapping(value="%s", method=RequestMethod.POST)' % url

    def processFuncAnnotation(self, service, func, annotation):
        if annotation.isUri():
            return self.processFuncUri(service, func, annotation)
        else:
            return self.processAnnotation(annotation)

    def processFunc(self, service, func):
        self.processFuncResult(func)
        buf = MsgBuf()
        buf.append(func.getComment())
        buf.appendEmptyLine()
        throwsparam=[]
        for annotation in func.annotations:
            # uri
            if annotation.isUri():
                buf.append(self.processFuncAnnotation(service, func, annotation))
            elif annotation.name == 'throws':
                throwsparam.append(annotation.params[0].value)

            #buf.appendEmptyLine()
        buf.appendEmptyLine()
        params = []
        global resultType
        for p in func.params:
            params.append(self.processParam(func, p))
        if throwsparam:
            buf.append('%s<%s> %s(%s)' % (resultType,func.returnType, func.name, ', '.join(params)))
            buf.appendEmptyLine()
            buf.append("throws %s;" % ','.join(throwsparam).replace('"',""))
            buf.appendEmptyLine()
        else:
            buf.append('%s<%s> %s(%s);' % (resultType,func.returnType, func.name, ', '.join(params)))
            buf.appendEmptyLine()
        self.imports.add(packageIndex[resultType])
        return buf

    def processFuncResult(self, func):
        if func.returnMapList():
            self.imports.add('java.util.List')
            self.imports.add('java.util.Map')
        elif func.returnMap():
            self.imports.add('java.util.Map')
        elif func.returnList():
            self.imports.add('java.util.List')

        self.addImport(func.getRelParam())


    def processParam(self, func, param):
        if param.isMapList():
            self.imports.add('java.util.List')
            self.imports.add('java.util.Map')
        elif param.isMap():
            self.imports.add('java.util.Map')
        elif param.isList():
            self.imports.add('java.util.List')

        self.addImport(param.getRelParam())

        self.imports.add('org.springframework.web.bind.annotation.RequestParam')
        if param.isList():
            return '@RequestParam(value="%s[]",required = false) %s %s' % (param.paramName, param.paramType, param.paramName)
        else:
            return '@RequestParam(value="%s",required = false) %s %s' % (param.paramName, param.paramType, param.paramName)

    def addImport(self,param):
        if isinstance(param,tuple):
            for p in param:
                if packageIndex.has_key(p):
                   self.imports.add(packageIndex[p])
        else:
            if packageIndex.has_key(param):
                self.imports.add(packageIndex[param])

    def processImports(self):
        buf = MsgBuf()
        buf.append('\n')
        for i in self.imports:
            exp = 'import %s;' % i
            buf.append(exp)
            buf.appendEmptyLine()
        return buf

    def processJavaPackage(self, javaPackage):
        return 'package %s;' % javaPackage

    def process(self, outputDir,service,package,model):
        packageName = packageToJavaInterfaceName(package)
        buf = MsgBuf()
        if service.getComment:
          buf.append(service.getComment())
          buf.appendEmptyLine()
        buf.append('public interface %s {' % service.name)
        buf.appendEmptyLine()
        for func in service.funcs:
            buf.append(self.processFunc(service, func), 1)
            buf.appendEmptyLine()
        buf.append("}")
        buf.appendEmptyLine()

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processImports())

        buf.prependEmptyLine()
        buf.prepend(self.processJavaPackage(package))

        self.output(outputDir,buf.output(),service.name)
        return packageName,buf.output()

    def initPackageInfo(self, packageName):
        buf = MsgBuf()
        #buf.append('@javax.annotation.Generated("This file is generated by Butterfly")')
        buf.appendEmptyLine()
        buf.append('public interface %s {' % packageName)
        return buf

    def output(self,outputDir,content,filename):
        outputFilename = os.path.join(outputDir, "%s.java" % filename)
        with open(outputFilename, 'w') as fp:
            fp.write(content)

    # def processPackage(self, services, package):
    #     packageName = packageToJavaInterfaceName(package)

    #     buf = MsgBuf()
    #     buf.append(self.initPackageInfo(packageName))
    #     buf.appendEmptyLine()

    #     for service in services:
    #         buf.append(self.process(service), 1)
    #         buf.appendEmptyLine()

    #     buf.append("}")

    #     buf.prependEmptyLine()
    #     buf.prepend(self.processNotModifyComment())

    #     buf.prependEmptyLine()
    #     buf.prepend(self.processImports())

    #     buf.prependEmptyLine()
    #     buf.prepend(self.processJavaPackage(package))
    #     return packageName, buf.output()

class RetrofitWriter(SpringMVCWriter):

    def init(self):
        self.imports=set()

    def processFuncUri(self, service, func, annotation):
        #url = annotation.params[0].value

        modelPath=annotation.params[0].value
        comment=func.getComment()
        version = func.getAnnotation('version')
        target_uri=func.getAnnotation('turi')
        if target_uri is None:
            serviceUri = service.getUri()
            servicePath=serviceUri.getServicePath()
            prefix=serviceUri.getPrefix()
            if prefix is not None:
                if not version:
                    url= '%s/%s/%s' % (prefix,servicePath,modelPath)
                else:
                    url= '%s/%s/%s?v=%s' % (prefix,servicePath,modelPath,version.params[0].value.strip('"'))
            else:
                if serviceUri is not None:
                    url = '%s/%s' % (servicePath, modelPath)
                if not version:
                    url = 'v%s/%s' % ('1', url)
                if version:
                    url = 'v%s/%s' % (version.params[0].value.strip('"'), url)
        else:
             url=target_uri.params[0].value.strip('"')


        self.imports.add('retrofit.http.POST')
        self.imports.add('retrofit.http.FormUrlEncoded')
        self.imports.add('retrofit.Call')
        self.imports.add('retrofit.http.Headers')
        buf = MsgBuf()
        if comment:
          buf.append(comment)
          buf.appendEmptyLine()
        if func.params:
          buf.append("@FormUrlEncoded")
          buf.appendEmptyLine()
          buf.append('@Headers("Content-Type: application/x-www-form-urlencoded; charset=utf-8")')
          buf.appendEmptyLine()
        buf.append('@POST(value="%s")' % url)
        return buf

    def processParam(self, func, param):
        if param.isMapList():
            self.imports.add('java.util.List')
            self.imports.add('java.util.Map')
        elif param.isMap():
            self.imports.add('java.util.Map')
        elif param.isList():
            self.imports.add('java.util.List')

        self.addImport(param.getRelParam())

        self.imports.add('retrofit.http.Field')
        if param.isList():
            return '@Field("%s[]") %s %s' % (param.paramName, param.paramType, param.paramName)
        else:
            return '@Field("%s") %s %s' % (param.paramName, param.paramType, param.paramName)


    def addImport(self,param):
        if isinstance(param,tuple) or isinstance(param,list):
            for p in param:
                if packageIndex.has_key(p):
                    self.imports.add(packageIndex[p])
        else:
            if packageIndex.has_key(param):
                self.imports.add(packageIndex[param])

    def processFunc(self, service, func):
        self.processFuncResult(func)
        buf = MsgBuf()
        for annotation in func.annotations:
            #uri
            if annotation.isUri():
                buf.append(self.processFuncAnnotation(service, func, annotation))
        buf.appendEmptyLine()
        params = []
        for p in func.params:
            params.append(self.processParam(func, p))
        # params.append('Callback<%s> callback' % func.returnType)
        buf.append('Call<%s> %s(%s);' % (func.returnType,func.name, ','.join(params)))
        buf.appendEmptyLine()
        return buf

class JavaPoJoModelWriter(object):
    def __init__(self):
        self.imports = set()

    def processNotModifyComment(self):
        return genJavaComment()

    def processJavaPackage(self, javaPackage):
        return 'package %s;' % javaPackage

    def processClassBegin(self, cls):
        buf = MsgBuf()
        #buf.append('@javax.annotation.Generated("this file is generated by Butterfly")')
        buf.append(cls.getComment())
        buf.appendEmptyLine()
        buf.append('public class %s%s {' % (cls.name.name,cls.name.getGenericName()))
        return buf

    def processProperty(self, p):
        if p.isMapList():
            self.imports.add('java.util.List')
            self.imports.add('java.util.Map')
        elif p.isMap():
            self.imports.add('java.util.Map')
        elif p.isList():
            self.imports.add('java.util.List')

        self.addImport(p.getRelParam())

        return 'private %s %s;' % (p.paramType, p.paramName)

    def addImport(self,param):
        if isinstance(param,tuple) or isinstance(param,list):
            for p in param:
                if packageIndex.has_key(p):
                    self.imports.add(packageIndex[p])
        else:
            if packageIndex.has_key(param):
                    self.imports.add(packageIndex[param])

    def processPropertyGet(self, p):
        # cname = p.paramName.capitalize()
        cname=p.paramName[0].upper() +  p.paramName[1:]
        return 'public %s get%s() { return this.%s; }' % (p.paramType, cname, p.paramName)

    def processPropertySet(self, p):
        # cname = p.paramName.capitalize()
        cname=p.paramName[0].upper() +  p.paramName[1:]
        return 'public void set%s(%s %s) { this.%s = %s; }' % (cname, p.paramType, p.paramName, p.paramName, p.paramName)

    def processImports(self):
        buf = MsgBuf()
        buf.append('\n')
        for i in self.imports:
            exp = 'import %s;' % i
            buf.append(exp)
            buf.appendEmptyLine()

        return buf

    def processBuilderWithFunc(self, model, p):
        buf = MsgBuf()
        # cname = p.paramName.capitalize()
        cname=p.paramName[0].upper() +  p.paramName[1:]
        buf.append("public %sBuilder%s with%s(%s %s) {" % (model.name.name,model.name.getGenericName(),cname, p.paramType, p.paramName))
        buf.append("    this.%s = %s; return this;" % (p.paramName, p.paramName))
        buf.append("}")
        return buf

    def processBuilderBuildFunc(self, model):
        buf = MsgBuf()
        buf.append("public %s%s build() {" % (model.name.name,model.name.getGenericName()))
        buf.appendEmptyLine()
        pbuf=MsgBuf()
        pbuf.append("%s m = new %s();" % (model.name.name, model.name.name))
        pbuf.appendEmptyLine()
        for p in model.properties:
            pbuf.append("m.%s = this.%s;" % (p.paramName, p.paramName))
            pbuf.appendEmptyLine()
        pbuf.append("return m;")
        pbuf.appendEmptyLine()
        pbuf.append("}")
        buf.append(pbuf,1)
        return buf

    def processBuilder(self, model):
        buf = MsgBuf()
        buf.appendEmptyLine()
        buf.append("public static class %sBuilder%s {" % (model.name.name,model.name.getGenericName()))
        for pro in model.properties:
            buf.append(self.processProperty(pro))
            buf.appendEmptyLine()
        for pro in model.properties:
            buf.append(self.processBuilderWithFunc(model, pro))
            buf.appendEmptyLine()
        buf.append(self.processBuilderBuildFunc(model))
        buf.appendEmptyLine()
        buf.append("}")
        buf.appendEmptyLine()
        return buf

    def process(self,outputDir,cls, package):
        buf = MsgBuf()

        if isAnnotationedBy(cls,"Deprecated"):
            buf.append("@Deprecated")
            buf.appendEmptyLine()
        buf.append(self.processClassBegin(cls))
        buf.appendEmptyLine()

        pbuf = MsgBuf()

        for pro in cls.properties:
            pbuf.append(self.processProperty(pro))
            pbuf.append(pro.getComment())
            pbuf.appendEmptyLine()
        pbuf.appendEmptyLine()
        for pro in cls.properties:
            pbuf.append(self.processPropertyGet(pro))
            pbuf.appendEmptyLine()
        pbuf.appendEmptyLine()
        for pro in cls.properties:
            pbuf.append(self.processPropertySet(pro))
            pbuf.appendEmptyLine()

        buf.append(pbuf, 1)

        if not isAnnotationedBy(cls, "NoBuilder"):
            buf.append(self.processBuilder(cls), 1)

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processImports())

        buf.prependEmptyLine()
        buf.prepend(self.processJavaPackage(package))

        buf.append('}')
        buf.appendEmptyLine()

        self.output(outputDir,buf.output(),cls.name.name)
        return buf.output()

    def output(self,outputDir,content,filename):
        outputFilename = os.path.join(outputDir, "%s.java" % filename)
        with open(outputFilename, 'w') as fp:
            fp.write(content)

class JavaPoJoModelWriterWithLomBok(JavaPoJoModelWriter):
    def __init__(self):
        self.imports = set()
        self.imports.add('lombok.Builder')
        self.imports.add('lombok.Data')
        self.imports.add('lombok.AllArgsConstructor')
        self.imports.add('lombok.NoArgsConstructor')

    def processClassBegin(self, cls):
        buf = MsgBuf()
        #buf.append('@javax.annotation.Generated("this file is generated by Butterfly")')
        buf.append(cls.getComment())
        buf.appendEmptyLine()
        buf.append('@Data @Builder @NoArgsConstructor @AllArgsConstructor public class %s%s {' % (cls.name.name,cls.name.getGenericName()))
        return buf

    def process(self,outputDir,cls, package):
        buf = MsgBuf()

        if isAnnotationedBy(cls,"Deprecated"):
            buf.append("@Deprecated")
            buf.appendEmptyLine()
        buf.append(self.processClassBegin(cls))
        buf.appendEmptyLine()

        pbuf = MsgBuf()

        for pro in cls.properties:
            pbuf.append(self.processProperty(pro))
            pbuf.append(pro.getComment())
            pbuf.appendEmptyLine()

        buf.append(pbuf, 1)

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processImports())

        buf.prependEmptyLine()
        buf.prepend(self.processJavaPackage(package))

        buf.append('}')
        buf.appendEmptyLine()

        self.output(outputDir,buf.output(),cls.name.name)
        return buf.output()

class AndroidPoJoModelWriter(JavaPoJoModelWriter):
    def __init__(self):
        self.imports = set()
        self.imports.add('org.parceler.Parcel')
        self.imports.add('lombok.Getter')
        self.imports.add('lombok.Setter')
        self.imports.add('lombok.Builder')
        self.imports.add('lombok.NoArgsConstructor')
        self.imports.add('lombok.AllArgsConstructor')

    def processClassBegin(self, cls):
        buf = MsgBuf()
        #buf.append('@javax.annotation.Generated("this file is generated by Butterfly")')
        buf.append(cls.getComment())
        buf.appendEmptyLine()
        buf.append('public class %s%s {' % (cls.name.name,cls.name.getGenericName()))
        return buf

    def processProperty(self, p, cls):
        if p.isMapList():
            self.imports.add('java.util.List')
            self.imports.add('java.util.Map')
        elif p.isMap():
            self.imports.add('java.util.Map')
        elif p.isList():
            self.imports.add('java.util.List')

        self.addImport(p.getRelParam())

        #Long,Integer,Float,Boolean -> long,int,float,boolean
        if p.paramType in ['Long','Float','Boolean','Double']:
            p.paramType=p.paramType.lower()
        elif p.paramType == 'Integer':
            p.paramType='int'
        elif p.paramType == 'BigDecimal':
            p.paramType="double"
        elif p.paramType == 'T':
            p.paramType="transient T"
        elif cls.name.getGenericName() != '' and (p.paramType.startswith('List') or p.paramType.startswith('Map')):
            p.paramType='transient %s' % (p.paramType)

        return '%s %s;' % (p.paramType, p.paramName)
    def process(self,outputDir,cls, package):
        buf = MsgBuf()

        buf.append('@Getter')
        buf.appendEmptyLine()
        buf.append('@Setter')
        buf.appendEmptyLine()
        buf.append('@Builder')
        buf.appendEmptyLine()
        buf.append('@Parcel')
        buf.appendEmptyLine()
        buf.append('@NoArgsConstructor')
        buf.appendEmptyLine()
        buf.append('@AllArgsConstructor')
        if isAnnotationedBy(cls,"Deprecated"):
            buf.append("@Deprecated")
            buf.appendEmptyLine()
        buf.append(self.processClassBegin(cls))
        buf.appendEmptyLine()

        pbuf = MsgBuf()

        for pro in cls.properties:
            pbuf.append(self.processProperty(pro, cls))
            pbuf.append(pro.getComment())
            pbuf.appendEmptyLine()
        pbuf.appendEmptyLine()

        buf.append(pbuf, 1)

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processImports())

        buf.prependEmptyLine()
        buf.prepend(self.processJavaPackage(package))

        buf.append('}')
        buf.appendEmptyLine()

        self.output(outputDir,buf.output(),cls.name.name)
        return buf.output()

class JavaPoJoEnumWriter(object):
    def __init__(self):
        self.imports = set()
        # self.imports.add("com.fasterxml.jackson.annotation.JsonCreator")
        # self.imports.add("com.fasterxml.jackson.annotation.JsonValue")

    def processNotModifyComment(self):
        return genJavaComment()

    def processJavaPackage(self, javaPackage):
        return 'package %s;' % javaPackage

    def processEnumBegin(self, cls):
        buf = MsgBuf()
        #buf.append('@javax.annotation.Generated("this file is generated by Butterfly")')
        buf.appendEmptyLine()
        buf.append('public enum %s {' % cls.name)
        return buf

    def processProperty(self, p):
        if p.desc:
            return '%s(%s, %s),' % (p.name, p.code, p.desc)
        else:
            return '%s(%s),' % (p.name, p.code)

    def processCode(self):
        buf = MsgBuf()
        buf.appendEmptyLine()
        buf.append('private final int code;')
        buf.appendEmptyLine()
        # buf.append('@JsonValue')
        buf.appendEmptyLine()
        buf.append('public int getCode() { return this.code; }')
        buf.appendEmptyLine()
        return buf

    def processDesc(self, cls):
        buf = MsgBuf()
        buf.append('private final String desc;')
        buf.appendEmptyLine()
        buf.append('public String getDesc() { return this.desc; }')
        buf.appendEmptyLine()
        return buf

    def processConstructor(self, cls):
        if cls.properties[0].desc is not None:
            return '%s(int code, String desc) { this.code = code; this.desc = desc; }' % cls.name
        else:
            return '%s(int code) { this.code = code; }' % cls.name

    def processFrom(self, cls):
        buf = MsgBuf()
        # buf.append("@JsonCreator")
        buf.appendEmptyLine()
        buf.append("public static %s fromCode(int code) {" % cls.name)
        buf.appendEmptyLine()
        buf.append("    for (%s v : %s.values()) {" % (cls.name, cls.name))
        buf.appendEmptyLine()
        buf.append("        if (v.code == code) {")
        buf.appendEmptyLine()
        buf.append("            return v;")
        buf.appendEmptyLine()
        buf.append("        }")
        buf.appendEmptyLine()
        buf.append("    }")
        buf.appendEmptyLine()
        # buf.append('    throw new IllegalArgumentException("code is error, is " + code);')
        buf.append('    return UNKNOWN_CODE;')
        buf.appendEmptyLine()
        buf.append('}')
        buf.appendEmptyLine()
        return buf

    def processGet(self, cls):
            buf = MsgBuf()
            # buf.append("@JsonCreator")
            buf.appendEmptyLine()
            buf.append("public static %s getEnum(String desc) {" % cls.name)
            buf.appendEmptyLine()
            buf.append("    for (%s v : %s.values()) {" % (cls.name, cls.name))
            buf.appendEmptyLine()
            buf.append("        if (v.getDesc().equalsIgnoreCase(desc)) {")
            buf.appendEmptyLine()
            buf.append("            return v;")
            buf.appendEmptyLine()
            buf.append("        }")
            buf.appendEmptyLine()
            buf.append("    }")
            buf.appendEmptyLine()
            # buf.append('    throw new IllegalArgumentException("code is error, is " + code);')
            buf.append('    return UNKNOWN_CODE;')
            buf.appendEmptyLine()
            buf.append('}')
            buf.appendEmptyLine()
            return buf

    def processImports(self):
        buf = MsgBuf()
        buf.append('\n')
        for i in self.imports:
            exp = 'import %s;' % i
            buf.append(exp)
            buf.appendEmptyLine()

        return buf

    def process(self,outputDir,cls, package):
        buf = MsgBuf()
        if cls.getComment():
            buf.append(cls.getComment())
        buf.append(self.processEnumBegin(cls))
        buf.appendEmptyLine()

        pbuf=MsgBuf()
        pbuf.append('UNKNOWN_CODE(-1, ""),')
        pbuf.appendEmptyLine()
        for p in cls.properties:
            pbuf.append(self.processProperty(p))
            pbuf.appendEmptyLine()
        pbuf.append(';')
        buf.append(pbuf,1)

        buf.appendEmptyLine()
        buf.append(self.processConstructor(cls),2)
        buf.appendEmptyLine()
        buf.append(self.processCode(),1)
        if cls.properties[0].desc is not None:
            buf.append(self.processDesc(cls),1)

        buf.append(self.processFrom(cls),1)
        buf.append(self.processGet(cls),1)

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processImports())

        buf.prependEmptyLine()
        buf.prepend(self.processJavaPackage(package))

        buf.append('}')
        buf.appendEmptyLine()
        self.output(outputDir,buf.output(),cls.name,package)
        return buf.output()

    def output(self,outputDir,content,filename,package):
        outputFilename = os.path.join(outputDir, "%s.java" % filename)
        if os.path.exists(outputFilename):
          oldfile = [line.rstrip() for line in open(outputFilename)]
          newfile=content.split('\n')
          newfile.pop()
          diff=difflib.ndiff(oldfile,newfile)
          changes = [l for l in diff if l.startswith('+ ') or l.startswith('- ')]
          if changes:
            print 'warn:contain the same class: <%s.%s>' % (package,filename)
            print '\n'.join(changes)

        with open(outputFilename, 'w') as fp:
            fp.write(content)

class JSPoJoEnumWriter(object):
    def __init__(self):
      self.imports = set()
    def processNotModifyComment(self):
        return genJavaComment()

    def processEnumBegin(self, cls):
        buf = MsgBuf()
        #buf.append('@javax.annotation.Generated("this file is generated by Butterfly")')
        buf.appendEmptyLine()
        buf.append('%s: {' % cls.name)
        return buf

    def processProperty(self, p):
        if p.desc:
            return '  \'%s\':%s,' % (p.code, p.desc)

    def process(self,outputDir,ele, package):
        buf = MsgBuf()
        buf.append("ENUM={")
        cbuf = MsgBuf()
        for i,c in enumerate(ele):
          if c.getComment():
              cbuf.appendEmptyLine()
              cbuf.append(c.getComment())
          cbuf.append(self.processEnumBegin(c))
          cbuf.appendEmptyLine()
          pbuf=MsgBuf()
          for p in c.properties:
              pbuf.append(self.processProperty(p))
              pbuf.appendEmptyLine()
          cbuf.append(pbuf)
          if (i+1)==len(ele):
            cbuf.append('}')
          else:
            cbuf.append('},')
        buf.append(cbuf,1)
        buf.appendEmptyLine()
        buf.append('}')
        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())
        self.output(outputDir,buf.output())
        return buf.output()

    def output(self,outputDir,content):
        outputFilename = os.path.join(outputDir, "enum.js")
        with open(outputFilename, 'w') as fp:
            fp.write(content)

class JsonPoJoEnumWriter(object):
    def __init__(self):
      self.imports = set()
    def processNotModifyComment(self):
        return genJavaComment()

    def processEnumBegin(self, cls):
        buf = MsgBuf()
        #buf.append('@javax.annotation.Generated("this file is generated by Butterfly")')
        buf.appendEmptyLine()
        buf.append('"%s": [' % cls.name)
        return buf

    def processProperty(self, p , isLast=False):
        if not isLast:
            return '  {"code":%s,"value":%s},' % (p.code, p.desc)
        else:
            return '  {"code":%s,"value":%s}' % (p.code, p.desc)

    def process(self,outputDir,ele, package):
        buf = MsgBuf()
        buf.append("{")
        cbuf = MsgBuf()
        for i,c in enumerate(ele):
          cbuf.append(self.processEnumBegin(c))
          cbuf.appendEmptyLine()
          pbuf=MsgBuf()
          cplen=len(c.properties)
          for j,p in enumerate(c.properties):
              pbuf.append(self.processProperty(p,j==cplen-1))
              pbuf.appendEmptyLine()
          cbuf.append(pbuf)
          if (i+1)==len(ele):
            cbuf.append(']')
          else:
            cbuf.append('],')
        buf.append(cbuf,1)
        buf.appendEmptyLine()
        buf.append('}')
        buf.prependEmptyLine()
        self.output(outputDir,buf.output())
        return buf.output()

    def output(self,outputDir,content):
        outputFilename = os.path.join(outputDir, "enum.json")
        with open(outputFilename, 'w') as fp:
            fp.write(content)

class ObjectCPoJoEnumWriter(object):
    def __init__(self):
        self.imports = set()
        self.imports.add("<Foundation/Foundation.h>")
        # self.imports.add("com.fasterxml.jackson.annotation.JsonCreator")
        # self.imports.add("com.fasterxml.jackson.annotation.JsonValue")

    def processNotModifyComment(self):
        return genJavaComment()

    def processEnumBegin(self, cls):
        buf = MsgBuf()
        #buf.append('@javax.annotation.Generated("this file is generated by Butterfly")')
        buf.appendEmptyLine()
        buf.append('typedef NS_ENUM (NSInteger, %s){' % cls.name)
        return buf

    def processProperty(self,cls,p):
        if p.desc:
            return '%s%s=%s, //%s' % (cls.name,p.name, p.code, p.desc)
        else:
            return '%s%s=%s,' % (cls.name,p.name, p.code)

    def processImports(self):
        buf = MsgBuf()
        buf.append('\n')
        for i in self.imports:
            exp = '#import %s' % i
            buf.append(exp,0)
            buf.appendEmptyLine()

        return buf

    def process(self,outputDir, cls, package):
        buf = MsgBuf()
        if cls.getComment():
            buf.append(cls.getComment())
        buf.append(self.processEnumBegin(cls))
        buf.appendEmptyLine()

        pbuf=MsgBuf()
        for p in cls.properties:
            pbuf.append(self.processProperty(cls,p))
            pbuf.appendEmptyLine()
        # pbuf.append(';')
        buf.append(pbuf,1)

        # if cls.properties[0].desc is not None:
        #     buf.append(self.processDesc(cls),1)

        # buf.append(self.processFrom(cls),1)

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processImports())

        buf.append('};')
        buf.appendEmptyLine()

        self.output(outputDir,buf.output(),cls.name)
        return buf.output()

    def output(self,outputDir,content,filename):
        outputFilename = os.path.join(outputDir, "%s.h" % filename)
        with open(outputFilename, 'w') as fp:
            fp.write(content)

# class ObjectCWriter(object):
#     def __init__(self):
#         self.imports = set()
#         self.imports.add("com.fasterxml.jackson.annotation.JsonCreator")
#         self.imports.add("com.fasterxml.jackson.annotation.JsonValue")

#     def processPackage(self, services, package):
#         buf = MsgBuf()
#         return buf;

class ObjectCModelWriter(object):
    def __init__(self):
        self.imports = set()
        self.imports.add("<Foundation/Foundation.h>")
        self.imports.add("<Mantle.h>")
        self.sourceImports = set()

    def processNotModifyComment(self):
        return genJavaComment()

    def processClassBegin(self,cls):
        buf = MsgBuf()
        buf.append(self.processModelComment(cls))
        buf.appendEmptyLine()
        buf.append('@interface %s : MTLModel<MTLJSONSerializing>' % cls.name.name)
        buf.appendEmptyLine()
        return buf

    def processModelComment(self,p):
        commentLines=""
        if p.comment:
            for c in p.comment:
                commentLines+=c
        return commentLines

    def processHeadImports(self):
        buf = MsgBuf()
        buf.append('\n')
        for i in self.imports:
            exp = '#import %s' % i
            buf.append(exp,0)
            buf.appendEmptyLine()
        return buf

    def processSourceImports(self):
        buf = MsgBuf()
        buf.append('\n')
        for i in self.sourceImports:
            exp = '#import %s' % i
            buf.append(exp,0)
            buf.appendEmptyLine()
        return buf

    def processProperty(self,p):
        relParamType=p.paramType
        if J2OBJC.get(p.paramType) is not None:
            relParamType=J2OBJC.get(p.paramType)
        else:
            if p.isList():
                relParamType=J2OBJC.get('List')
            elif p.isMap():
                relParamType=J2OBJC.get('Map')
            else:
                self.imports.add('"%s.h"' % relParamType)
        paramName=p.paramName
        if paramName == 'id':
            paramName='oid'
        elif paramName == 'description':
            paramName = 'odescription'

        if relParamType in ['NSInteger','float','double','long long','BOOL']:
            return '@property(nonatomic, assign) %s %s; %s' % (relParamType,paramName,self.processModelComment(p))
        if relParamType in ['NSArray','NSDictionary']:
            arrayComment="//"+p.paramType
        else:
            arrayComment=""
        return '@property(nonatomic, strong) %s *%s; %s%s' % (relParamType,paramName,arrayComment,self.processModelComment(p))

    def processJSONPropertyKeyMap(self,params):
        buf = MsgBuf()
        buf.append('+ (NSDictionary *)JSONKeyPathsByPropertyKey {')
        buf.appendEmptyLine()
        buf.append('return @{')
        buf.appendEmptyLine()
        pbuf= MsgBuf()
        for p in params:
            if p.paramName == "id":
                pbuf.append('@"oid":@"id",')
                pbuf.appendEmptyLine()
                continue
            elif p.paramName == "description":
                pbuf.append('@"odescription":@"description",')
                pbuf.appendEmptyLine()
                continue
            pbuf.append('@"%s":@"%s",' % (p.paramName,p.paramName))
            pbuf.appendEmptyLine()
        pbuf.append('};')
        buf.append(pbuf,1)
        buf.appendEmptyLine()
        buf.append('}')
        buf.appendEmptyLine()
        return buf

    def processMTLValueTransformer(self,params):
        buf = MsgBuf()
        for p in params:
            relParamType=p.paramType
            if J2OBJC.get(p.paramType) is  None:
                if p.isList():
                    relParam=p.getRelParam()[0] if isinstance(p.getRelParam(),list) else p.getRelParam()
                    if p.getRelParam() in ['String','Integer','Boolean']:
                        continue
                    buf.append("+ (MTLValueTransformer *)%sJSONTransformer {" % p.paramName)
                    buf.appendEmptyLine()
                    buf.append("    return [MTLValueTransformer transformerUsingForwardBlock:^id(NSArray *value, BOOL *success, NSError *__autoreleasing *error) {")
                    buf.appendEmptyLine()
                    buf.append("        return [MTLJSONAdapter modelsOfClass:[%s class] fromJSONArray:value error:nil];" % relParam)
                    buf.appendEmptyLine()
                    buf.append("    } reverseBlock:^id(NSArray *value, BOOL *success, NSError *__autoreleasing *error) {")
                    buf.appendEmptyLine()
                    buf.append("         return [MTLJSONAdapter JSONArrayFromModels:value error:nil];")
                    buf.appendEmptyLine()
                    buf.append("    }];")
                    buf.appendEmptyLine()
                    buf.append("}")
                    buf.appendEmptyLine()
                    self.sourceImports.add('"%s.h"' % relParam)
                elif p.isMap():
                    pass
                else:
                    p.paramType=p.paramType[0] if isinstance(p.paramType,list) else p.paramType
                    relParamType=J2OBJC.get(p.paramType)
                    buf.append(" + (MTLValueTransformer *)%sJSONTransformer {" % p.paramName)
                    buf.appendEmptyLine()
                    buf.append("    return [MTLValueTransformer transformerUsingForwardBlock:^id(NSDictionary *value, BOOL *success, NSError *__autoreleasing *error) {")
                    buf.appendEmptyLine()
                    buf.append("        return [MTLJSONAdapter modelOfClass:[%s class] fromJSONDictionary:value error:nil];" % p.paramType)
                    buf.appendEmptyLine()
                    buf.append("    } reverseBlock:^id(%s *value, BOOL *success, NSError *__autoreleasing *error) {" % p.paramType)
                    buf.appendEmptyLine()
                    buf.append("        return [MTLJSONAdapter JSONDictionaryFromModel:value error:nil];")
                    buf.appendEmptyLine()
                    buf.append("    }];")
                    buf.appendEmptyLine()
                    buf.append("}")
                    buf.appendEmptyLine()

            elif J2OBJC.get(p.paramType) == 'BOOL':
                buf.append(" + (NSValueTransformer *)%sJSONTransformer {" % p.paramName)
                buf.appendEmptyLine()
                buf.append("    return [NSValueTransformer valueTransformerForName:MTLBooleanValueTransformerName];")
                buf.appendEmptyLine()
                buf.append("}")
                buf.appendEmptyLine()

        return buf

    def processInit(self,params):
        nsarray=[param.paramName for param in params if param.isList()]
        buf = MsgBuf()
        if nsarray:
            buf.append('- (id)init {')
            buf.appendEmptyLine()
            buf.append('    self = [super init];')
            buf.appendEmptyLine()
            for array in nsarray:
                buf.append('    self.%s = [NSArray array];' % array)
                buf.appendEmptyLine()
            buf.append('    return self;')
            buf.appendEmptyLine()
            buf.append('}')
            buf.appendEmptyLine()
            buf.appendEmptyLine()
        return buf

    def processDefaultFuncHeader(self):
        buf = MsgBuf()
        buf.append("- (id)initWithDict:(NSDictionary *)dict;")
        buf.appendEmptyLine()
        buf.append("+ (id)initWithDict:(NSDictionary *)dict;")
        buf.appendEmptyLine()
        return buf

    def processDefaultInitWithDic(self):
        buf = MsgBuf()
        buf.append("- (id)initWithDict:(NSDictionary *)dict {")
        buf.appendEmptyLine()
        pbuf = MsgBuf()
        pbuf.append("if (self = [super init]) {")
        pbuf.appendEmptyLine()
        pbuf.append("[self setValuesForKeysWithDictionary:dict];")
        pbuf.appendEmptyLine()
        pbuf.append("}")
        pbuf.appendEmptyLine()
        pbuf.append("return self;")
        pbuf.appendEmptyLine()
        buf.append(pbuf,1)
        buf.append("}")
        buf.appendEmptyLine()
        return buf

    def processDefaultFuncInit(self):
        buf = MsgBuf()
        buf.append("+ (id)initWithDict:(NSDictionary *)dict {")
        buf.appendEmptyLine()
        pbuf = MsgBuf()
        pbuf.append("return [[self alloc] initWithDict:dict];")
        pbuf.appendEmptyLine()
        buf.append(pbuf,1)
        buf.append("}")
        buf.appendEmptyLine()
        return buf

    def processHeader(self, cls, package):
        buf = MsgBuf()
        buf.append(self.processClassBegin(cls))
        buf.appendEmptyLine()
        pbuf = MsgBuf()

        for pro in cls.properties:
            pbuf.append(self.processProperty(pro))
            pbuf.appendEmptyLine()

        pbuf.appendEmptyLine()
        pbuf.append(self.processDefaultFuncHeader())

        buf.append(pbuf, 0)

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processHeadImports())

        buf.appendEmptyLine()
        buf.append('@end')
        buf.appendEmptyLine()
        return buf.output()

    def processSource(self,cls,package):
        buf = MsgBuf()
        buf.append("@implementation %s" % cls.name.name)
        buf.appendEmptyLine()
        self.sourceImports.add("\"%s.h\"" % cls.name.name)
        buf.appendEmptyLine()
        buf.append(self.processJSONPropertyKeyMap(cls.properties))
        buf.appendEmptyLine()
        buf.append(self.processMTLValueTransformer(cls.properties))
        buf.appendEmptyLine()
        buf.append(self.processInit(cls.properties))
        buf.append(self.processDefaultInitWithDic())
        buf.appendEmptyLine()
        buf.append(self.processDefaultFuncInit())
        buf.appendEmptyLine()

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processSourceImports())
        buf.append("@end")
        buf.appendEmptyLine()
        return buf.output()

    def process(self,outputDir,cls,package):
        outHead=self.processHeader(cls,package)
        outSource=self.processSource(cls,package)
        self.outputH(outputDir,outHead,cls.name.name)
        self.outputM(outputDir,outSource,cls.name.name)
        return outHead,outSource

    def outputH(self,outputDir,content,filename):
        outputFilename = os.path.join(outputDir, "%s.h" % filename)
        with open(outputFilename, 'w') as fp:
            fp.write(content)

    def outputM(self,outputDir,content,filename):
        outputFilename = os.path.join(outputDir, "%s.m" % filename)
        with open(outputFilename, 'w') as fp:
            fp.write(content)

class ObjectiveCServiceWriter(BaseWriter):

    def init(self):
        self.imports.add('<Foundation/Foundation.h>')
        self.imports.add('"NetWorkAgent.h"')
        self.imports.add('"Mantle.h"')
        self.sourceImports = set()

    def processNotModifyComment(self):
        return genJavaComment()

    def processHeadImports(self):
        buf = MsgBuf()
        buf.append('\n')
        for i in self.imports:
            exp = '#import %s' % i
            buf.append(exp,0)
            buf.appendEmptyLine()
        return buf

    def processSourceImports(self):
        buf = MsgBuf()
        buf.append('\n')
        for i in self.sourceImports:
            exp = '#import %s' % i
            buf.append(exp,0)
            buf.appendEmptyLine()
        return buf

    def processFuncImport(self, func):
        param=func.getRelParam()
        if isinstance(param,tuple) or isinstance(param,list):
            for p in param:
                if len(p)>0 and p.lower() not in ['<','>','list','map'] and J2OBJC.get(p) is None:
                    self.sourceImports.add('"%s.h"' % p)
        else:
            if J2OBJC.get(param) is None:
                print param
                self.sourceImports.add('"%s.h"' % param)

    def processParam(self,func,param):
        relParamType=param.paramType
        if J2OBJC.get(param.paramType) is not None:
            relParamType=J2OBJC.get(param.paramType)
            #long long NSNumber
            if relParamType in ["long long","NSInteger"]:
                relParamType = 'NSNumber'
        else:
            self.imports.add('"%s.h"' % relParamType)
        paramName=param.paramName
        if paramName == 'id':
            paramName='oid'
        elif paramName == 'description':
            paramName='odescription'

        #long long NSNumber
        if relParamType == "long long":
            relParamType = 'NSNumber'
        if relParamType not in ['NSString','NSNumber','NSArray']:
            return '%s:(%s)%s ' % (paramName,relParamType,paramName)
        return '%s:(%s *)%s ' % (paramName,relParamType,paramName)

    def checkParam(self,func):
        checkParam=[]
        for param in func.params:
          relParamType=param.paramType
          if J2OBJC.get(param.paramType) is not None:
              relParamType=J2OBJC.get(param.paramType)
          paramName=param.paramName
          if paramName == 'id':
              paramName='oid'
          elif paramName == 'description':
              paramName='odescription'

          if relParamType in ['NSString','NSNumber']:
              checkParam.append("nil!=%s" % paramName)
        return checkParam


    def processPostParam(self,func,param):
        relParamType=param.paramType
        if J2OBJC.get(param.paramType) is not None:
            relParamType=J2OBJC.get(param.paramType)
            if relParamType in ['long long','NSInteger']:
                relParamType = "NSNumber"
        else:
            self.imports.add('"%s.h"' % relParamType)
        paramName=param.paramName
        if paramName == 'id':
            if relParamType not in ['NSString','NSNumber']:
                return '@"id":@(oid)'
            return '@"id":oid'
        elif paramName == 'description':
            return '@"description":odescription'
        if relParamType not in ['NSString','NSNumber','NSArray']:
            return '@"%s":@(%s)' % (param.paramName,param.paramName)
        return '@"%s":%s' % (param.paramName,param.paramName)

    def processFuncAnnotation(self, service, func, annotation):
        if annotation.isUri():
            return self.processFuncUri(service, func, annotation)

    def processFuncUri(self, service, func, annotation):
        modelPath=annotation.params[0].value
        version = func.getAnnotation('version')
        target_uri = func.getAnnotation('turi')
        if target_uri is None:
            serviceUri = service.getUri()
            prefix=serviceUri.getPrefix()
            servicePath=serviceUri.getServicePath()
            if prefix is not None:
                if not version:
                    url= '%s/%s/%s' % (prefix,servicePath,modelPath)
                else:
                    url= '%s/%s/%s?v=%s' % (prefix,servicePath,modelPath,version.params[0].value.strip('"'))
            else:
                if serviceUri is not None:
                    url = '%s/%s' % (servicePath, modelPath)
                if not version:
                    url = 'v%s/%s' % ('1', url)
                if version:
                    url = 'v%s/%s' % (version.params[0].value.strip('"'), url)
        else:
            url=target_uri.params[0].value.strip('"')

        return url

    def processSourceFunc(self,service,func,model):
        self.processFuncImport(func)
        buf = MsgBuf()

        buf.appendEmptyLine()
        buf.append("- (void)%sBy" % func.name)

        postparam=[]
        rbuf=MsgBuf()
        for p in func.params:
            rbuf.append(self.processParam(func,p))
            postparam.append(self.processPostParam(func,p))

        rbuf.append('success:(NetworkSuccessBlock)success failure:(NetworkFailureBlock)failure{')
        requestParams=rbuf.output()
        requestParams=requestParams[0].upper() +  requestParams[1:]
        # buf.append(requestParams[requestParams.find(':')+1:])
        buf.append(requestParams)
        buf.appendEmptyLine()
        # buf.append(pbuf)
        # pdb.set_trace()
        pbuf=MsgBuf()
        for annotation in func.annotations:
            if annotation.name == 'version':
                continue
            if annotation.isUri():
                if len(postparam)>0:
                    allparams="@{%s}" % ",".join(postparam)
                else:
                    allparams="nil"
                # if len(self.checkParam(func))>0:
                if False:
                    pbuf.append("if(%s){" % '&&'.join(self.checkParam(func)))
                    pbuf.appendEmptyLine()
                    pbuf.append('  [[NetWorkAgent sharedInstance] requestWith:@"%s" param:%s success:^(id result) {' % (self.processFuncUri(service,func,annotation),allparams))
                    pbuf.appendEmptyLine()
                    if J2OBJC.get(func.returnType) is not None:
                        returnType=J2OBJC.get(func.returnType)
                        pbuf.append('    success(result);')
                    else:
                        if func.returnList():
                            for p in func.getRelParam():
                                if len(p) > 0 and p.lower() not in ['<','list','>','map']:
                                    returnType=p
                                    break
                            pbuf.append('    NSArray *classes = [MTLJSONAdapter modelsOfClass:[%s class] fromJSONArray:result error:nil];' % returnType)
                        else:
                            pbuf.append('    %s *classes = [MTLJSONAdapter modelOfClass:[%s class] fromJSONDictionary:result error:nil];' % (func.returnType,func.returnType))
                        pbuf.appendEmptyLine()
                        pbuf.append('    success(classes);')
                    pbuf.appendEmptyLine()
                    pbuf.append('  } failure:failure];')
                    pbuf.appendEmptyLine()
                    pbuf.append('}else{')
                    pbuf.appendEmptyLine()
                    pbuf.append('  DLog(@"error:");')
                    pbuf.appendEmptyLine()
                    pbuf.append('}')
                else:
                    pbuf.append('[[NetWorkAgent sharedInstance] requestWith%s:@"%s" param:%s success:^(id result) {' % (model,self.processFuncUri(service,func,annotation),allparams))
                    pbuf.appendEmptyLine()
                    if J2OBJC.get(func.returnType) is not None:
                        returnType=J2OBJC.get(func.returnType)
                        pbuf.append('success(result);')
                    else:
                        if func.returnList():
                            for p in func.getRelParam():
                                if len(p) > 0 and p.lower() not in ['<','list','>','map']:
                                    returnType=p
                                    break
                            pbuf.append('  NSArray *classes = [MTLJSONAdapter modelsOfClass:[%s class] fromJSONArray:result error:nil];' % returnType)
                            pbuf.appendEmptyLine()
                            pbuf.append('  success(classes);')
                        elif func.returnMap() or func.returnMapList():
                            pbuf.append('  success(result);')
                        else:
                            pbuf.append('  %s *classes = [MTLJSONAdapter modelOfClass:[%s class] fromJSONDictionary:result error:nil];' % (func.returnType,func.returnType))
                            pbuf.appendEmptyLine()
                            pbuf.append('  success(classes);')
                    pbuf.appendEmptyLine()
                    pbuf.append('} failure:failure];')

        # for p in func.params:
        #     pbuf.append('[param setValue:%s forKey:@"%s"];' %(p.paramName,p.paramName))
        #     pbuf.appendEmptyLine()
        # pbuf.append("[NetWorkUtils sendMessage:path")
        # pbuf.appendEmptyLine()
        # pbuf.append("param:param")
        # pbuf.appendEmptyLine()
        # pbuf.append("CompletionHandler:response")
        # pbuf.appendEmptyLine()
        # pbuf.append("errorHandler:error];")
        buf.append(pbuf,1)
        buf.appendEmptyLine()
        buf.append('}')
        return buf

    def processM(self,service,model):
        buf=MsgBuf()
        #buf.append("+ (void)%s:%s" % service.name)
        for func in service.funcs:
            if func.getComment():
                buf.appendEmptyLine()
                buf.append(func.getComment())
            buf.append(self.processSourceFunc(service,func,model))
            buf.appendEmptyLine()

        return buf;

    def processHeaderFunc(self,service,func):
        buf = MsgBuf()
        # pdb.set_trace()
        # first=func.params[0];
        # if first:
        #     del func.params[0]

        # relParamType=first.paramType
        # if J2OBJC.get(first.paramType.lower()) is not None:
        #     relParamType=J2OBJC.get(first.paramType.lower())
        # else:
        #     self.imports.add('"%s.h"' % relParamType)

        buf.appendEmptyLine()
        buf.append("- (void)%sBy" % func.name)
        pbuf=MsgBuf()
        for p in func.params:
            pbuf.append(self.processParam(func,p))
        pbuf.append('success:(NetworkSuccessBlock)success failure:(NetworkFailureBlock)failure;')
        # allparams=pbuf.output()
        # buf.append(allparams[allparams.find(':')+1:])
        requestParams=pbuf.output()
        requestParams=requestParams[0].upper() +  requestParams[1:]
        buf.append(requestParams)
        # buf.append(pbuf)
        # pbuf.append("CompletionHandler:(MKNKResponseBlock)response")
        # pbuf.appendEmptyLine()
        # pbuf.append("errorHandler:(MKNKResponseErrorBlock)error;")
        # buf.append(pbuf,1)
        return buf


    def processH(self,service):
        buf=MsgBuf()
        buf.appendEmptyLine()
        #buf.append("+ (void)%s:%s" % service.name)
        for func in service.funcs:
            if func.getComment():
                buf.appendEmptyLine()
                buf.append(func.getComment())
            buf.appendEmptyLine()
            buf.append("//Return:"+func.returnType)
            buf.append(self.processHeaderFunc(service,func))
            buf.appendEmptyLine()

        return buf;

    def typeChange(self):
        relParamType=p.paramType
        if J2OBJC.get(p.paramType) is not None:
            relParamType=J2OBJC.get(p.paramType)
        else:
            self.imports.add('"%s.h"' % relParamType)


    def processHeader(self,services,package,model):
        packageName = packageToJavaInterfaceName(package)
        buf = MsgBuf()
        buf.appendEmptyLine()
        buf.append("@interface %s : NSObject" % services.name)
        # for service in services:
        buf.append(self.processH(services),0)
        buf.appendEmptyLine()

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processHeadImports())

        buf.append("@end")
        return buf.output()


    def processSource(self, services, package,model):
        packageName = packageToJavaInterfaceName(package)

        buf = MsgBuf()

        #buf.append(self.initPackageInfo(packageName))
        buf.appendEmptyLine()
        self.sourceImports.add("\"%s.h\"" % services.name)
        buf.append("@implementation %s" % services.name)
        buf.appendEmptyLine()

        # for service in services:
        buf.append(self.processM(services,model),0)
        buf.appendEmptyLine()

        buf.prependEmptyLine()
        buf.prepend(self.processNotModifyComment())

        buf.prependEmptyLine()
        buf.prepend(self.processSourceImports())

        buf.append("@end")
        return  buf.output()

    def process(self,outputDir,cls,package,model):
        outHead=self.processHeader(cls,package,model)
        outSource=self.processSource(cls,package,model)
        self.outputH(outputDir,outHead,cls.name)
        self.outputM(outputDir,outSource,cls.name)
        return outHead,outSource

    def outputH(self,outputDir,content,filename):
        outputFilename = os.path.join(outputDir, "%s.h" % filename)
        with open(outputFilename, 'w') as fp:
            fp.write(content)

    def outputM(self,outputDir,content,filename):
        outputFilename = os.path.join(outputDir, "%s.m" % filename)
        with open(outputFilename, 'w') as fp:
            fp.write(content)
J2OBJC={
    "String":"NSString",
    "int":"NSInteger",
    "Boolean":"BOOL",
    "boolean":"BOOL",
    "Integer":"NSNumber",
    "long":"long long",
    "Long":"NSNumber",
    "float":"float",
    "Float":"NSNumber",
    "Object":"NSObject",
    "List":"NSArray",
    "List<String>":"NSArray",
    "List<Integer>":"NSArray",
    "List<Long>":"NSArray",
    "T":"NSObject",
    "R":"NSObject",
    "double":"double",
    'Double':"NSNumber",
    "BigDecimal":"double",
    "map":"NSDictionary"
}


WriterPackageDict = {
        'SpringMVC': {'enum': JavaPoJoEnumWriter, 'model': JavaPoJoModelWriterWithLomBok, 'service': SpringMVCWriter},
        'Retrofit': {'enum': JavaPoJoEnumWriter, 'model': AndroidPoJoModelWriter, 'service': RetrofitWriter},
        'ios': {'enum': ObjectCPoJoEnumWriter, 'model': ObjectCModelWriter, 'service': ObjectiveCServiceWriter},
         'js': {'enum': JSPoJoEnumWriter, 'model': ObjectCModelWriter, 'service': ObjectiveCServiceWriter},
         'json': {'enum': JsonPoJoEnumWriter, 'model': ObjectCModelWriter, 'service': ObjectiveCServiceWriter},
        }

def main(inputFile, package, outputDir=None, writer=None, model=None, debug=True, **kw):
    writer = writer or "SpringMVC"
    outputDir= outputDir or "."
    outputDir = os.path.abspath(outputDir)

    # files = set()
    # for root, dirs, fs in os.walk(inputDir):
    #     if not fs:
    #         continue
    #     root = os.path.abspath(root)
    #     for f in fs:
    #         files.add(os.path.join(root, f))

    s = parseObjFromFile(inputFile)
    WriterPackage = WriterPackageDict[writer]
    for ele in s.elements:
        if isinstance(ele, Service):
            out = WriterPackage['service']().process(outputDir,ele, package,model)
            if debug:
                print out[1]
            # else:
            #     outputFilename = os.path.join(outputDir, "%s.java" % ele.name)
            #     with open(outputFilename, 'w') as fp:
            #         fp.write(out[1])

    for ele in s.elements:
        if isinstance(ele, Enum):
            out = WriterPackage['enum']().process(outputDir,ele, package)
            if debug:
                print out
            # else:
            #     WriterPackage['enum']().output(outputDir,out,ele.name)
                # outputFilename = os.path.join(outputDir, "%s.java" % ele.name)
                # with open(outputFilename, 'w') as fp:
                #     fp.write(out)
        elif isinstance(ele, Model):
            out = WriterPackage['model']().process(outputDir,ele, package)
            if debug:
                print out
            # else:
            #     WriterPackage['model']().output(outputDir,out,ele.name.name)
                # outputFilename = os.path.join(outputDir, "%s.java" % ele.name.name)
                # with open(outputFilename, 'w') as fp:
                #     fp.write(out)
def main2(inputFile, package, outputDir=None, writer=None, debug=True, **kw):
    writer = writer or "js"
    outputDir= outputDir or "."
    outputDir = os.path.abspath(outputDir)
    eles = parseObjFromFile(inputFile)
    WriterPackage = WriterPackageDict[writer]
    enums=[]
    eindex=[]
    for ele in eles.elements:
      if isinstance(ele, Enum):
        if ele.name not in eindex:
           enums.append(ele)
           eindex.append(ele.name)
    out = WriterPackage['enum']().process(outputDir,enums, package)
    if debug:
        print out

packageIndex=dict()

def updateClassIndex(inputDir,package):
    # import pdb;pdb.set_trace()
    for root, dirs, fs in os.walk(inputDir):
        if not fs:
            continue
        root = os.path.abspath(root)
        for f in fs:
            sf=os.path.join(root, f)
            if f.endswith(".java"):
                continue
            f=f.split('.')
            f.reverse()
            targetPackage=package+"."+".".join(f)
            s = parseObjFromFile(sf)
            for ele in s.elements:
                if isinstance(ele,Model):
                    packageIndex[ele.name.name]=targetPackage+"."+ele.name.name
                else:
                    packageIndex[ele.name]=targetPackage+"."+ele.name

    # print packageIndex

resultType="MsgResult"
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--output', help='output')
    parser.add_argument('--input', help='input')
    parser.add_argument('--writer', help="writer to process")
    parser.add_argument('--package', help="package name")
    parser.add_argument('--resultType', help="result wrapper class")
    parser.add_argument('--model', help="model in project",default="")
    parser.add_argument('--debug', help="debug", action="store_true", default=False)
    args = parser.parse_args()
    resultType='MsgResult'
    if args.resultType is not None:
        resultType=args.resultType
    if (args.writer=='SpringMVC') or (args.writer=='Retrofit'):
        if not (args.input and args.package):
            raise Exception("argument error")
        #
        updateClassIndex(args.input,args.package)
        for root, dirs, fs in os.walk(args.input):
            if not fs:
                continue
            root = os.path.abspath(root)
            for f in fs:
                sourceFilePath=os.path.join(root, f)
                if f.endswith(".java"):
                    package=args.package+".contants"
                    outputDir=os.path.join(args.output,package.replace(".",os.path.sep))
                    if not os.path.exists(outputDir):
                        os.makedirs(outputDir)
                    shutil.copy(sourceFilePath,  outputDir)
                    continue
                filename=f.split('.')
                filename.reverse()
                targetPackage=args.package+"."+".".join(filename)
                outputDir=os.path.join(args.output,targetPackage.replace(".",os.path.sep))
                if not os.path.exists(outputDir):
                   os.makedirs(outputDir)
                main(sourceFilePath, targetPackage, outputDir=outputDir, debug=args.debug, writer=args.writer, model=args.model)
    elif args.writer == 'ios':
        if not (args.input):
            raise Exception("argument error")
        for root, dirs, fs in os.walk(args.input):
            if not fs:
                continue
            root = os.path.abspath(root)
            for f in fs:
                sourceFilePath=os.path.join(root, f)
                filename=f.split('.')
                filename.reverse()
                outputDir=os.path.join(args.output,os.path.sep.join(filename))
                if not os.path.exists(outputDir):
                   os.makedirs(outputDir)
                main(sourceFilePath, args.package, outputDir=outputDir, debug=args.debug, writer=args.writer,model=args.model)

    elif (args.writer=='js') or (args.writer=='json'):
        if not (args.input):
            raise Exception("argument error")
        sourcefiles=[]
        for root, dirs, fs in os.walk(args.input):
            if not fs:
                continue
            root = os.path.abspath(root)
            for f in fs:
              sourceFilePath=os.path.join(root, f)
              sourcefiles.append(sourceFilePath)
        outputDir=args.output
        if not os.path.exists(outputDir):
           os.makedirs(outputDir)
        enumfile=os.path.join(outputDir,'enum.js')
        if os.path.exists(enumfile):
          os.remove(enumfile)
        main2(sourcefiles, args.package, outputDir=outputDir, debug=args.debug, writer=args.writer)
